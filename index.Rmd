---
title: "Open Case Studies: School Shootings in the United States"
css: style.css
output:
  html_document:
    self_contained: yes
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes

---

<style>
#TOC {
  background: url("https://opencasestudies.github.io/img/logo.jpg");
  background-size: contain;
  padding-top: 240px !important;
  background-repeat: no-repeat;
}
</style>


<!-- Open all links in new tab-->  
<base target="_blank"/> 

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE, cache = FALSE,
                      fig.align = "center", out.width = '90%')
library(here)
library(knitr)
```

#### {.outline }
```{r, echo=FALSE}
knitr::include_graphics(here("img", "aboutpagelook.png"))
```
####

AVOCADO: What is the black around the image above? 

AVOCADO: no questions or answers? 

#### {.disclaimer_block}

**Disclaimer**: The purpose of the [Open Case Studies](https://opencasestudies.github.io){target="_blank"} project is **to demonstrate the use of various data science methods, tools, and software in the context of messy, real-world data**. A given case study does not cover all aspects of the research process, is not claiming to be the most appropriate way to analyze a given data set, and should not be used in the context of making policy decisions without external consultation from scientific experts. 

####

#### {.license_block}

This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 [(CC BY-NC 3.0)](https://creativecommons.org/licenses/by-nc/3.0/us/){target="_blank"} United States License.

####

#### {.reference_block}

To cite this case study please use:

Wright, Carrie, and Ontiveros, Michael and Jager, Leah and Taub, Margaret and Hicks, Stephanie. (2020). https://github.com/opencasestudies/ocs-youth-school-shootings-dashboard-case-study. Open Case Studies: School Shootings in the United States (Version v1.0.0).

####

For users or instructors who only wish to look at the basics of how to create a dashboard in R with the `flexdashboard` package, please see the [**Dashboard Basics**] Section. 

# **Motivation**
*** 

This case study is motivated by this [article](https://link.springer.com/content/pdf/10.1007/s11920-012-0331-6.pdf):

#### {.reference_block}

Flannery, D. J., Modzeleski, W. & Kretschmar, J. M. Violence and School Shootings. Curr Psychiatry Rep 15, 331 (2013). DOI: [10.1007/s11920-012-0331-6](https://doi.org/10.1007/s11920-012-0331-6)

####

The article explores characteristics of school shootings and violence in schools and discusses why these events may occur, as well as their impact on the communities in which they occur.

The article also states that the shooters are most commonly white males, but that many previous studies of shooter characteristics could not identify any particular "profile" of shooters.

AVOCADO: I am starting to read through this section, but I'm a bit confused. A lot of the text in this section isn't clear to me why it's here. We do not look at profiles of the shooter in the dashboard? 

> "To date, studies of school shootings have concluded that no
consistent and reliable profile of school shooters exist, and
most researchers and clinicians would agree that predicting
violent behavior is a slippery slope that will usually result in
more false positives than false negatives."

However previous studies note some commonalities such as:

> "...most shooters were depressed, had experienced some significant
loss, felt persecuted or bullied by others, and had prior
difficulty coping or had previously tried suicide. Most of
the shooters did not, however, have a history of drug abuse
or violence or cruelty to animals, common psychiatric indicators of risk, nor did they report excessive exposure to
violence in the media (though many produced their own
violent themes in writings or drawings)."


```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "joshua-hoehne-CAokgx1GGKE-unsplash.jpg"))
```

<span>Photo by <a href="https://unsplash.com/@mrthetrain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Joshua Hoehne</a> on <a href="https://unsplash.com/s/photos/high-school?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>

> "School shootings are not all the same and may require
different approaches to prevention and treatment, especially
with respect to identifying risk factors at the individual, school
or community levels, and particularly with regard to examining
the role that mental health issues may play to increase risk for
perpetration. The field **needs to know more** about shooting
incidents that are averted, those that result in injury but not
death and about the characteristics of the more common occurrence of single homicide school shootings."


```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "andre-hunter-AQ908FfdAMw-unsplash.jpg"))
```

<span>Photo by <a href="https://unsplash.com/@dre0316?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Andre Hunter</a> on <a href="https://unsplash.com/s/photos/high-school?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>


They also point out that:

> "Most media attention is on the mental health of school shooters, but we cannot forget the **impact of school shooting incidents on the surviving victims**, including those who may not have been injured but who may have witnessed the incident or been affected by it in other ways. Psychiatrists must pay attention to the long-term mental health consequences of these incidents on all affected parties (not just formal PTSD diagnoses, but related trauma symptoms) as well as maladaptive coping strategies that some may employ in response to such unpredictable, tragic events."

Given this need for more research to better understand why these events occur and how they could be averted, in this case study we will demonstrate how to create a resource for others to more easily and interactively access data about school shootings. To do so we will create what is called a [dashboard](https://en.wikipedia.org/wiki/Dashboard_(business)), which is a website that displays a report for a database. Dashboards summarize the data in a database and typically allow for users to interact with the data in some way.

[Here](https://beta.rstudioconnect.com/jjallaire/htmlwidgets-highcharter/htmlwidgets-highcharter.html) you can see an example of a dashboard created in R about sales forecasts of food.

AVOCADO: while I think the dashboard you linked to is interesting, it's not very well labeled or have much documentation? I'm guessing it has something to do with sales forecasts. Should we add more info? 

On the website the tabs and and plots are interactive. The above dashboard allows for users to get to know the data in a simple and quick way.

The data about food sales is succinctly summarized in an impactful manner.

```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "dashboard.png"))
```

##### [[source]](https://beta.rstudioconnect.com/jjallaire/htmlwidgets-highcharter/)

Now let's learn how to do this with our data of interest.

# **Main Questions**
*** 

#### {.main_question_block}
<b><u> Our main questions: </u></b>

1) What has been the yearly rate of school shootings and where have they occurred in the last 50 years (from January 1970 to June 2020)? 

2) What are the characteristics of these events?

####

AVOCADO: the second question is pretty generic. I haven't read any further yet, but at this point I do not know what you mean by "characteristics of these events". Could we make this question more specific? 

AVOCADO: Also, becuase we are focused on maps in dashboards, should we add a main question that has to do with the spatial?

# **Learning Objectives** 
*** 

In this case study, we will demonstrate how to create a [dashboard](https://en.wikipedia.org/wiki/Dashboard_(business)), which is a website that displays a report about a database. We will especially focus on using packages and functions from the [`tidyverse`](https://www.tidyverse.org/){target="_blank"}, such as `package_name`, `package_name`. The tidyverse is a library of packages created by RStudio. While some students may be familiar with previous R programming packages, these packages make data science in R more human-readable and intuitive.


```{r, out.width = "20%", echo = FALSE, fig.align ="center"}
include_graphics("https://tidyverse.tidyverse.org/logo.png")
```

The skills, methods, and concepts that students will be familiar with by the end of this case study are:


Data science skills:  
  
1. Importing text from a Google Sheets document (`googlesheets4`)  
2. Converting date formats (`lubridate`)  
3. Geocoding data (`ggmap`)  and creating a jitter for geocoded data on a map (`SF`)
4. How to reshape data by pivoting between "long" and "wide" formats and drop rows with `NA` values (`tidyr`)  
5. How to create data visualizations with `ggplot2` 
6. An introduction to understand basics of R Markdown  
7. How to create an interactive table (`DT`)  
8. How to create a map (`leaflet`)  
9. How to create an interactive dashboard with `flexdashboard` and `shiny`  

Statistical concepts and methods:  
  
1. Calculating percentages for data with missing values  

*** 


We will begin by loading the packages that we will need:


```{r}
library(here)
library(readr)
library(googlesheets4)
library(tibble)
library(dplyr)
library(stringr)
library(magrittr)
library(tidyr)
library(ggmap)
library(sf)
library(lubridate)
library(DT)
library(htmltools)
library(ggplot2)
library(forcats)
library(ggforce)
library(waffle)
library(poliscidata)
library(flexdashboard)
library(shiny)
library(leaflet)
library(maps)
library(vembedr)
```


 <u>**Packages used in this case study:** </u>

Package   | Use in this case study                                                                      
---------- |-------------
[here](https://github.com/jennybc/here_here){target="_blank"}       | to easily load and save data  
[readr](https://readr.tidyverse.org/) |  to import the data  as a csv file  
[googlesheets4](https://googlesheets4.tidyverse.org/) | to import directly from Google Sheets
[tibble](https://tibble.tidyverse.org/) | to create tibbles (the tidyverse version of dataframes)
[dplyr](https://dplyr.tidyverse.org/){target="_blank"}      | to filter, subset, join, add rows to, and modify the data  
[stringr](https://stringr.tidyverse.org/){target="_blank"}      | to manipulate  character strings within the data (collapsing strings together, replace values, and detect values)
[magrittr](https://magrittr.tidyverse.org/){target="_blank"}      | to pipe sequential commands 
[tidyr](https://tidyr.tidyverse.org/){target="_blank"}      | to change the shape or format of tibbles to wide and long, to drop rows with `NA` values, and to see the last few columns of a tibble
[ggmap](https://cran.r-project.org/web/packages/ggmap/ggmap.pdf) | to geocode the data (which means get the latitude and longitude values)
[sf](https://r-spatial.github.io/sf/) | to modify the geocoded data so that overlapping points did not overlap
[lubridate](https://lubridate.tidyverse.org/) | to work with the data-time data    
[DT](https://rstudio.github.io/DT/) | to create the interactive table  
[htmltools](https://www.rdocumentation.org/packages/htmltools/versions/0.5.0) | to add a caption to our interactive table 
[ggplot2](https://ggplot2.tidyverse.org/){target="_blank"}      | to create plots  
[ggforce](https://cran.r-project.org/web/packages/ggforce/ggforce.pdf)   | to create a plot zoom
[forcats](https://forcats.tidyverse.org/){target="_blank"}      | to reorder factor for plot
[waffle](https://github.com/hrbrmstr/waffle) | to make waffle proportion plots  
[poliscidata](https://cran.r-project.org/web/packages/poliscidata/poliscidata.pdf) | to get population values for the states
[flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/)     | to create the dashboard  
[shiny](https://shiny.rstudio.com/){target="_blank"}      | to allow our dashboard to be interactive   
[leaflet](https://rstudio.github.io/leaflet/shiny.html) | to implement the [leaflet](http://leafletjs.com/) (a JavaScript library for maps) to create the map for our dashboard   
[maps]() | AVOCADO: needs to be added. Rmd did not compile otherwise. 
[vembedr]() | AVOCADO: needs to be added. Rmd did not compile otherwise. 


The first time we use a function, we will use the `::` to indicate which package we are using. Unless we have overlapping function names, this is not necessary, but we will include it here to be informative about where the functions we will use come from.


# **Context**
*** 

AVOCADO: where does the statement "Although school shooting events that result in homicide are rare" come from? I thought it came from the dashboard you built? or are you citing a paper? i guess my point is, how would a reader know that info at this point? 

Although school shooting events that result in homicide are rare, they can have a lasting impact on the communities in which they occur. Furthermore, suicide events and shootings with no victims can have a lasting impact on the community.

According to the [Center for Injury Research and Prevention at the Children's Hospital of Philadelphia](https://injury.research.chop.edu/violence-prevention-initiative/types-violence-involving-youth/school-shootings):

>The most common shootings on school grounds rarely involve large numbers of victims, but even a shooting of just one student at school has ramifications far beyond those directly involved. Students and staff that witness school shootings are likely to suffer from [traumatic stress](https://en.wikipedia.org/wiki/Traumatic_stress) symptoms, become anxious or depressed and have general concerns about their safety. While many witnesses will have temporary symptoms, others will be symptomatic for a much longer period of time and even develop chronic psychiatric disorders. Even short-term impairments can cause severe distress and have profound effects on academic achievement and the social and emotional growth of impacted students. 
 
Furthermore, fatal shootings can have vast and lasting impacts because many students can witness a single event.

Another recently published [article](https://siepr.stanford.edu/sites/default/files/publications/19-036.pdf) indicates that:

> Over **240,000** American students experienced a school shooting in the last two decades.

```{r, echo=FALSE}
knitr::include_graphics(here::here("img", "exposed.png"))
```

##### [[source]](https://siepr.stanford.edu/sites/default/files/publications/19-036.pdf)
 
This study followed students who experienced a school shooting the United States between 2008 and 2013 and assessed their mental well-being. They found that:

> Fatal school shootings have large and persistent impacts on the mental health of local youth. In the two years following a fatal school shooting, the monthly number of antidepressant prescriptions written to individuals under age 20 is 21.3 percent higher in the shooting-exposed relative to the reference areas. 

```{r, echo = FALSE, outwidth = "40%"}
knitr::include_graphics(here::here("img", "fernando-cferdo-6x2iKGi6SPU-unsplash.jpg"))
```

<span>Photo by <a href="https://unsplash.com/@cferdo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Fernando @cferdo</a> on <a href="https://unsplash.com/s/photos/depression?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>

AVOCADO: While I think the info in this section is interesting, it's not clear to me why it's relevant to the case study? Could we explain more or edit and take out material not directly relevant? 

#### {.reference_block}

Rossin-Slater, M., Schnell, M., Schwandt, H., Trejo, S. & Uniat, L. Local Exposure to School Shootings and Youth Antidepressant Use. w26563 http://www.nber.org/papers/w26563.pdf (2019) doi:10.3386/w26563.

####
 
# **Limitations**
*** 
There are some important considerations regarding this data analysis to keep in mind: 

1) This analysis is exploratory and, as such, does not intend to provide inferential conclusions.  

2) This dashboard only uses one source of data. There may be school shooting events that are not listed in this data or errors in this data.

AVOCADO: what do you mean by "inferential conclusions"? Based on the main questions, you aren't asking if e.g. "there is a difference between two groups"? 

According to the database website itself:

>"This database was developed from open-source information and may include reporting errors."

Furthermore, according to this [article](https://link.springer.com/article/10.1007/s11920-012-0331-6), schools are not required to report school shootings unless they resulted in a suicide or homicide. Therefore there may be more events that result in only injury or no injuries or death that may not be included.

There are indeed events in the dataset that include zero deaths and zero injuries, but it is very likely that many of these events are not listed.

Avocado... this source from 2013 says that schools are not required to report.. is this still true?


# **What are the data?**
*** 

We will use data from the open-source [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) downloaded from the [Center for Homeland Defense and Security](https://www.chds.us/c/) at the at the [Naval Postgraduate School(NPS)](https://en.wikipedia.org/wiki/Naval_Postgraduate_School) in Monterey, California. This data is updated daily. The data used in this case study was downloaded in June of 2020. 

#### {.reference_block}

Riedman, David, and Desmond O’Neill. “CHDS – K-12 School Shooting Database.” Center for Homeland Defense and Security, June 2020, [www.chds.us/ssdb](www.chds.us/ssdb).

####

This database includes information about school shooting events for students in grades K-12 in the United States dating back to 1970. The database has additional information not shown on our dashboard including but not limited to: 

- Location of the event at the school  
- If the event occurred during a sporting event  
- Time of day of the event  
- Day of the week of the event  
- Source for the shooting information  
- If the event was pre-planned or not  
- Shooter's actions immediately following the shooting  
- Shooter characteristics (affiliation with the school, if they had accomplices, if they took hostages, and their age and race)  
- Victim characteristics (affiliation with the school, if they were targeted, their age and race)  

According to the [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) website:

> The School Shooting Database Project is conducted as part of the [Advanced Thinking in Homeland Security (HSx)](https://www.chds.us/c/academic-programs/hsx/) program at the Naval Postgraduate School’s [Center for Homeland Defense and Security (CHDS)](Center for Homeland Defense and Security (CHDS).

AVOCADO: the last link above seems like you forgot to paste in the URL and just copied the text twice? 

> The database compiles information from more than 25 different sources including peer-reviewed studies, government reports, mainstream media, non-profits, private websites, blogs, and crowd-sourced lists that have been analyzed, filtered, deconflicted, and cross-referenced. All of the information is based on open-source information and 3rd party reporting.


# **Data Import**
*** 

To start this section, we downloaded a `.CSV` file from the [K-12 School Shooting Database](https://www.chds.us/ssdb/dataset/) website. We can import this raw `.CSV` file using the `read_csv()` function of the `readr` package. Let's start by only importing the first five rows with the `n_max` argument which is the max number of rows to read in from the file.  

AVOCADO: maybe a link to how you found the file on the website? or sentence?

We will use the `here()` function of the `here` package to easily locate the data within the `raw_data` directory within the main directory that contains the `.Rproj` file.

```{r}
shooting_data <- 
  readr::read_csv(file = here::here("raw_data",
                                    "K-12_SSDB_(Public)-K-12_SSDB_(Public)_Linked.csv"), 
                 n_max = 5)
shooting_data
```

We see the first row is a sentence that states: 

> "Updated 6/2/2020 - View graphs and research methodology on www.chds.us/ssdb If you have information about other incidents, please email K12ssdb@chds.us."

We do not need this information, so we can skip it using the `skip` argument of `read_csv()` function. Specifically, we specify that we wish to only skip 1 row with `skip = 1`. We can also specify that the next row should be used for column names using the `col_names = TRUE` argument. 

```{r}
shooting_data <- 
  readr::read_csv(file = here::here("raw_data",
                                    "K-12_SSDB_(Public)-K-12_SSDB_(Public)_Linked.csv"), 
                  col_names = TRUE, skip = 1)
```

We can use the `glimpse` function of the `dplyr` package to take a look at columns within the database:

#### {.scrollable }
```{r}
# Scroll through the output!
glimpse(shooting_data)
```

####

We can also use the utils `str()` function to see more details about the values. Typically we would be able to see these with `glimpse()` but some of the columns have very long names, thus obscuring the first few values in the output.

AVOCADO: maybe a brief sentence on what `str()` means and does? 

#### {.scrollable }
```{r}
# Scroll through the output!
str(shooting_data)
```

AVOCADO: could we point out anything that might be useful for the student to know by looking through this? e.g. something that you address in data explore and wrangling section such as noting there is no state name and how it would be nice if a state name existed (vs just abbreivation)

####

Alternatively, if we wanted to make a dashboard that continually updated as the data got updated, we could do the following to import the data directly from the Google Sheets document.

AVOCADO: how did you know it was a google sheets doc? Above you said it was just a CSV file? 

To do so we would use the `read_sheet()` function of the `googlesheets4` package. Typically authentication is required, which is generally simple, but since this is a public sheet we do not need to worry about authentication. To avoid this we would need to use the `gs4_deauth()` function which puts the package into a de-authorized state. 

AVOCADO: you mention "authentication" or "de-authorized", but do we need to explain what we mean by that? 

```{r}
googlesheets4::gs4_deauth()
```

Great, now we would need to get the shared link from the document. We can do so by clicking on the link to the actually Google Sheets document like so:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "gettodoc.png"))
```

Then we can click on the "share" button to get access to the link:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "gettoshare.png"))
```

Finally we can click on "copy link" button to copy the link:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "getlink.png"))
```

Once you have copied the link, you can use the `read_sheet()` function to import the data by simply pasting the link in quotes, like so:

```{r eval = FALSE}
data_url <- "https://docs.google.com/spreadsheets/d/1HqbfMxnk9X3_mQvLyW_LEUe3Yyr7cXMPfwqUVfdq7sY/edit?usp=sharing"

googlesheet_data <- 
  read_sheet(data_url)
```

This is a great option, however, we chose not to do this for this case study to allow this tutorial to be more easily maintained over time.

####

# **Data Exploration and Wrangling**
***
Luckily, our data is already in pretty good shape, but we want to make our data more useful for our dashboard. 

## Adding state name

It would be useful to have the full state name in our data, rather than just the abbreviation.

We can do so by using data related to the US 50 states in a dataset called `state` that is automatically loaded with R sessions in the `datasets` package. The `state.abb` object is a list of the state abbreviations and `state.name` is a list of the state names.

```{r}
state.abb
state.name
```

We will combine these using the `tibble()` function of the `tibble()` package. 

```{r}
state_df <- 
  tibble(State_abb = state.abb, 
         State = state.name)

slice_head(state_df, n=4)
```

Now we will combine this with our data using the `left_join()` function of the `dplyr` package.
There are several ways to join data using the `dplyr` package.

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "join.png"))
```

##### [[source]](https://dplyr.tidyverse.org/reference/join.html)

Here is  a visualization of these options:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "join_image.png"))
```

##### [[source]](https://rstudio.com/resources/cheatsheets/)

See [here](https://dplyr.tidyverse.org/reference/join.html) for more details about joining data.

We probably have data for all fifty states, but there may not have been shootings in all 50 states in this dataset, therefore we don't want to use the `full_join()` function. We also don't want the `inner_join()` function because `DC` does not have a state name. Thus we will use the `left_join(x,y)` function where `x` in this case will be the `shooting_data` (as it is introduced to this code first through the `%<>%` compound assignment pipe operator) and `y` is the `state_df`. Thus, we add the `state_df` values where they match to the `shooting_data`.


The `%<>%` compound operator allows us to use the an input and reassign it at the end after all the subsequent steps have been performed. We can therefore use `data_input %<>%` instead of `data_input <- data_input %>%`. We will demonstrate this in the code below.

```{r}
shooting_data %<>%
  rename("State_abb" = State) %>%
  left_join(state_df, by = c("State_abb" = "State_abb"))
```


In contrast, we can just use the `%>%` pipe operator to select a set of columns and peek at the first four rows of the new data frame.  

***
<details> <summary>Click here if you are unfamiliar with piping in R, which uses this `%>%` operator.</summary>  

By [piping](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) we mean using the `%>%` pipe operator which is accessible after loading the `tidyverse` or several of the packages within the tidyverse like `dplyr` because they load the [`magrittr` package](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html). 
This allows us to perform multiple sequential steps on one data input.
The object on the left side is used as input to any commands to the right or below.

</details>  
***

```{r}
shooting_data %>%
  select(School, City, State_abb, State) %>%
  slice_head(n = 4)
```

## Reformatting dates

We also want to reformat our date values and create a `Date_year` variable based on the year in each date. We can use the `lubridate` package for this.

The `mdy()` function converts dates into a format where dates are listed as month, date, and year with hyphens in between.
The `year()` function can then be used to extract just the year from each date.

```{r}
shooting_data %<>%
  mutate(Date = lubridate::mdy(Date)) %>%
  mutate(Date_year = lubridate::year(Date))

shooting_data %>% 
  select(Date, Date_year)
```
Looks good!

## Reformatting data types

If you recall, in our dataset we have many variables that have either `Yes` or `No` values or `Y` and `N` values.  

```{r}
colnames(shooting_data)
```

These are the variables that have `Y/N` in the name or the `Targeted Specific Victim(s)`, `Random Victims`, `Pre-planned school attack` variables. 

We can make these consistently `TRUE` and `FALSE` by using the `case_when()` function of the `dplyr` package. This function allows us to specify new values for existing values, similarly to the `recode()` function also of `dplyr`. The benefit of the `case_when()` function, is that changing the values to `TRUE` or `FALSE` also results in the class type of the variable changing to type logical (which is interpreted as a binary variable with `TRUE` and `FALSE` values) otherwise, with `recode()` the variables would remain as class type character. 

***
<details> <summary> Click here for an explanation about data types in R. </summary>

There are several classes of data in R programming. 
Character is one of these classes. 
A character string is an individual data value made up of characters. 
This can be a paragraph, like the legend for the table, or it can be a single letter or number like the letter `"a"` or the number `"3"`. 
If data are of class character, than the numeric values will not be processed like a numeric value in a mathematical sense. 

If you want your numeric values to be interpreted that way, they need to be converted to a numeric class. 
The options typically used are integer (which has no decimal place) and double precision (which has a decimal place). 

Similarly if your data is of class character and are values of `TRUE` and `FALSE` they will be interpreted as two different strings. 

However, **logical data** is interpreted slightly differently where a `FALSE` value indicates the absence of something, while a `TRUE` indicates the presence of something.

</details>

***

<details><summary> Click here for more details about the differences between the `recode()` and `case_when()` functions. </summary>

Note, that with `recode()` there is the option that other values be recoded to `NA` although this is not the default, however with `case_when()` other values not explicitly assigned in the `case_when()` statement will be assigned to `NA`. Further more only values can be used on the left side when using `recode()` whereas `case_when()` accepts expressions.

</details>

***

AVOCADO: you mention "quotation marks necessary", but no explaination of what you mean by that? 

OK let's start by looking at the columns of interest by using the `select()` function and asking for any patterns that match the character string "Y/N" or "Specific" or "Random" or "Pre-planned". 
Formally, we can search for these using the `|` symbol, which is interpreted as an or, thus any variables that has a name that matches any of these patterns will be changed. 

```{r}
shooting_data %>% 
  select(matches("Y/N|Specific|Random|Pre-planned"))
```
We see the `Yes` and `No` values. Let's look closer at one of these columns. 

```{r}
shooting_data %>% 
  count(`Suicide (or attempted suicide) by Shooter (Y/N)`)
```
We see there are six different values in this column. To recode this column, we need to consider what we recode all the values. 

To implement the `case_when()` recoding of values, the existing values are written on the left of the `~` sign (quotation marks necessary) and new values are written on the right (quotations marks are not necessary as these are `TRUE` and `FALSE` statements).

```{r}
shooting_data %>%
       select(`Suicide (or attempted suicide) by Shooter (Y/N)`) %>%
       mutate(type = dplyr::case_when(. == "Yes" ~ TRUE,
                                      . == "No" ~ FALSE,
                                      . == "Y" ~ TRUE,
                                      . == "N" ~ FALSE,
                                      . == "Officer Involved" ~ TRUE))
```

In the above code chunk, we did this for one of the columns, but now let's do for all the columns that matched our string "Y/N|Specific|Random|Pre-planned" as above. 

To do this, we will use the `across()` function of the `dplyr` package and the `matches()` function of the `tidyselect` package to allow us to apply this to all of the variables that have a pattern that that matches any of those of the variables we want to change. 

The `across()` function then applies the `case_when()` function to all of these variables. Notice that the `~` symbol is necessary before the function that is applied using `across()`.


```{r}
shooting_data %<>%
  mutate(dplyr::across(.cols = matches("Y/N|Specific|Random|Pre-planned"),
                       ~ dplyr::case_when(. == "Yes" ~ TRUE,
                                          . == "No" ~ FALSE,
                                          . == "Y" ~ TRUE,
                                          . == "N" ~ FALSE,
                                          . == "Officer Involved" ~ TRUE)))
```

Finally, we can check out what happened after recoding the variables.  

```{r}
shooting_data %>% 
  select(matches("Y/N|Specific|Random|Pre-planned"))
```

Looks good!

## Geocoding with the `ggmap` package

For the purpose of our dashboard, we are interested in creating a map. 

To do this, we need to perform a process called [geocoding](https://en.wikipedia.org/wiki/Geocoding). Geocoding is the process of converting addresses into latitude and longitude coordinates.

To perform the geocoding we need the address of each school in the data set. The data currently does not list the actual address, but does have information about the school where the event occurred. 

Since some schools have the same name, we need the city and state data as well. So we will create a new variable in our data called `address` using the `mutate()` function of the `dplyr` package. 

This variable will collapse the values in the `School`, `City`, and `State` columns but with spaces in between. It is specified such that there will be space in between by the `sep = " "` argument. 

**Note**: a space is typed between the quotation marks. 

In this way, we then can use the address variable to look up the latitude and longitude for each school.

```{r}
shooting_data %<>%
  dplyr::mutate(address = 
                  stringr::str_c(School, City, State_abb, sep = " "))
```

We can take a look at just this new `address` variable using the `pull()` function of the `dplyr()` package.

```{r}
shooting_data %>%
  dplyr::pull(address) %>% 
  head()
```

Now we can use these addresses to find the latitude and longitude coordinates for each school where a school shooting occurred. 

To do this, we will use the `geocode()` function of the `ggmap` package to look up these addresses on Google Maps to get the latitude and longitude values. In the `geocode()` function, we also need to specify that we want to use google as the source using the `source` argument and that we want latitude and longitude using the `output = c("latlon")` argument.

This step requires registering with the Google Cloud Platform to get an API key, which currently requires registering your payment information and agreeing to the [Google Maps API Terms of Service](https://developers.google.com/maps/terms).

Therefore, we will simply demonstrate how this process works in general, but you are not required to do this yourself. 

***
<details><summary> Click here to see how we registered with the Google Cloud Platform.</summary>

If you were to do this process yourself, you could get an API key [here](https://cloud.google.com/maps-platform/). Again this requires registering your payment information, but it is free to got an API key and enable the APIs, however you can be billed based on how many addresses you look up using the APIs. You need to look up thousands before getting billed.

Then you need to enable the maps and places APIs, by clicking on the boxes next to each:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "enable.png"))
```

Then you would register like so after copying the API key: (Note this is a fake key)

```{r, eval = FALSE}
ggmap::register_google(key = "mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg") 
```

</details>

***

Once we have obtained an API key and registered, we can geocode our data.

Note that this step is time intensive, as there are many addresses to look up! Therefore, we will just show how this is done.

```{r, eval=FALSE}
shooting_data <- 
  shooting_data %>%
  mutate(coords = ggmap::geocode(address, 
                                 output = c("latlon"), 
                                 source = c("google")))

readr::write_csv(shooting_data, 
                 path = here("processed_data",
                             "shooting_data_geo.csv"))
```

This results in tibble called `coords` being added to our `shooting_data` tibble. That's right we can have a tibble as a column or variable within a tibble.   Using the `glimpse` function again, and looking at the last few variables, we can see that now the last variable listed is `coords` of class `<tibble>`.

```{r,echo = FALSE, out.width="90%"}
knitr::include_graphics(here::here("img", "shooting_data_coords.png"))
```

If we take a look at the first couple of values of the `coords` tibble, using the `slice_head()` function of the `dplyr` package, we see a tibble that looks like this:

AVOCADO: I didn't understand this section. Should we read in file where you show the `slice_head()` function? Otherwise, i'm not sure the purpose of stating it? 

```{r,echo = FALSE, out.width="30%"}
knitr::include_graphics(here::here("img", "coords.png"))
```

It would be better if each of these were their own columns in the tibble, so we will create new `longitude` and `latitude` variables again using the `mutate` function like so:

```{r, eval = FALSE}
shooting_data <- 
  shooting_data %>%
  mutate(longitude = pull(coords,lon),
         latitude = pull(coords,lat))
```

In this case we use the `pull()` function to grab the `lat` and `lon` variables within the `coords` tibble which is a variable of the `shooting_data` tibble.

We can now remove the `coords` tibble like so, using the `select()` function of the `dplyr` package:

```{r, eval = FALSE}  
shooting_data <- 
  shooting_data %>%
  dplyr::select(-coords)
```

Now using `glimpse()` and looking at the last several variables, we can see that we no longer have a `coords` variable, but we do have two variables called `longitude` and `latitude` that are of class double as indicated by the `<dbl>`:

```{r,echo = FALSE, out.width="80%"}
knitr::include_graphics(here::here("img", "double.png"))
```

Now we will save the geocoded data in the `processed_data` directory using the `write_csv` function of the `readr` package.

This requires listing the R object, followed by the path for where the file should be saved and what it should be called. In this case it will be called "shooting_data_geo.csv".

```{r, eval = FALSE} 
readr::write_csv(shooting_data, 
                 path = here("processed_data",
                             "shooting_data_geo.csv"))
```

AVOCADO: there is a lot of `eval=FALSE` in this section. Should we put it in a "details" box? or should we have a file what we read in at the beginning of this section and demonstrate the code? 

Great now we will work with this data, thus you do not need to get an API key to get to this point. We can read our processed geocoded data into R by using the `read_csv()` function of the `readr` package.

```{r}
shooting_data_geocoded <- 
  read_csv(here("processed_data",
                "shooting_data_geo.csv"))
```



## Geometry lists with the `sf` package

In this section, we will use the `sf` (which stands for simple features) package to 
create what is called a geometry list of our latitude and longitude information for the schools where shootings occurred. As some school shootings occurred in the same location, we need to alter all of the locations a bit so that when we plot the data on a map, so that the spots indicating where shootings occurred will not overlap for the same location.

Let's learn how to do this. 

```{r}
shooting_data_geocoded %>% 
  select(latitude, longitude) %>% 
  slice_head(n = 5)
```

First, let's remind ourselves how many rows we have in our dataset.

```{r}
dim(shooting_data_geocoded)
```

This is important because not all rows have a recorded latitude and longitude. 

```{r}
shooting_data_geocoded %>% 
  filter(is.na(latitude)) %>% 
  select(matches(c("long", "lat", "add")))
```

Therefore, before we can proceed, we need to remove rows with `NA` values for the `latitude` and `longitude` variables. In other words, we need to remove rows of events that happened at schools with locations that were not identified by Google. 

We can remove these rows using the `drop_na()` function of the `tidyr` package. We will use a `.` to indicate that we want to use the data that we are using as an input with our pipe, but then we will specify that we want to only drop rows were there is an `NA` value for either the `latitude` or `longitude` variables.

```{r}
shooting_data_geocoded %<>%
 tidyr::drop_na(., c(latitude, longitude))
```

How many did we remove? Let's look at the dimension of our new dataset. 

```{r}
dim(shooting_data_geocoded)
```

We see that there were 5 events that occurred at schools with unidentified complete locations (missing either latitude, longitude, or both) that were removed from our dataset. 

Next, we are ready to convert our coordinates variables (`latitude` and `longitude`) into a coordinate simple feature (or `sf` object) using the `st_as_sf()` function (converts foreign object to an `sf` object). 

To do this, we need to specify what our coordinate variables are and we will also specify what [coordinate reference system](https://www.w3.org/2015/spatial/wiki/Coordinate_Reference_Systems),(crs) we would like to use. In our case we will use the [ESPG](https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset) reference number [4326](https://spatialreference.org/ref/epsg/4326/), known as ESPG:4326 or the [World Geodetic System (WGS) version 84](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84) which is one of the most commonly used CPS and used by by most global positioning systems, known as GPS. **This tells R  to use the values for the variables called `latitude` and `longitude` as latitude and longitude coordinates.**

```{r}
shooting_data_geocoded %<>%
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

dim(shooting_data_geocoded)
```

We can see that our `latitude` and `longitude` variables were used to create a single new variable called `geometry` of class  `<POINT` [$^{\circ}$]`>`, thus we have one less column.

In this case, we can take a look at just the first 4 variables and we will also see our last `sf` variable as well appended at the end. So now we can see the variables related to location by simply typing `[1:4]` next to the name of our tibble `shooting_data_geocoded`.

AVOCADO: The section above doesn't make sense to me. If you want to see the first four variables, why do you index it like `[1:4]`?

```{r}
shooting_data_geocoded[1:4]
```

To allow our points to not overlap for events that took place in the same location, we will add a bit more range so that they do not overlap one another on our map. 
To do this, we will transform the coordinates using the `st_transform()` function  of the `sf` package into a two dimensional projection (called the [Albers equal-area conic projection](https://en.wikipedia.org/wiki/Albers_projection#:~:text=The%20Albers%20equal%2Darea%20conic,that%20uses%20two%20standard%20parallels.&text=The%20Albers%20projection%20is%20used,the%20United%20States%20Census%20Bureau.)) with units in meters using the [crs 102008](https://spatialreference.org/ref/esri/102008/html/) and then use the `st_jitter()` of the `sf` package function to allow a specified amount of range near the actual original GPS coordinates. In this case we will allow for 50 meters of range.

AVOCADO: how did you possibly know about this? From a reader's point of view, it comes a bit of out left field.... :/ 

To learn more about geospatial coordinate systems see [here](https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf) and [here](https://guides.library.duke.edu/r-geospatial/CRS).

So here we can see the output after transforming our data:

```{r}
shooting_data_geocoded  %<>%
  st_transform(crs = 102008) 
```

```{r}
shooting_data_geocoded[1:4]
```
And here we can see the output after adding the jitter:

```{r}
shooting_data_geocoded %<>%
   st_jitter(amount = 50)

shooting_data_geocoded[1:4]
```

**Note**: the `geometry` values have changed.

Now we will transform our coordinates back into the 3D latitude and longitude degree system again using the `st_transform()` function and the [ESPG:4326](https://spatialreference.org/ref/epsg/4326/), coordinate system.

```{r}
shooting_data_geocoded  %<>%
  st_transform(crs = 4326)

shooting_data_geocoded[1:4]
```

Notice how the `geometry` variables are different from what they were originally with this coordinate system:

```{r, echo = FALSE, out.width= "90%"}
knitr::include_graphics(here::here("img", "geometry.png"))
```

Next, we separate the `geometry` variable into `longitude` and `latitude` variables again. We can use the ` st_coordinates()` function of the `sf` package to extract the coordinates from our tibble as a matrix.

```{r}
shooting_data_geocoded %<>% 
  mutate(coordinates = as_tibble(st_coordinates(.)))

shooting_data_geocoded %>%
  pull(coordinates) %>%
  slice_head(n = 4)
```

Now, just as we did previously we will create new variables called `latitude` and `longitude` from the `X` and `Y` variables within the `coordinates` tibble that is part of our `shooting_data_geocoded` using the `pull()` function.

We will also convert our `shooting_data_geocoded` object which is currently a `sf` into a tibble using the `as_tibble()` function of the `tibble` package and then we will remove the `geometry` and `coordinates` variables using the `select()` function of the `dplyr` package with a minus operator in front of the names of the variables to remove.

```{r}
shooting_data_geocoded %<>%
  mutate(longitude = pull(coordinates,X),
          latitude = pull(coordinates,Y)) %>%
  tibble::as_tibble() %>%
  select(-geometry) %>%
  select(-coordinates)
```

And now we can take a look at  our last 3 variables using the `last_col()` function, which is a `select()` helper function `tidyr` package (See [here](https://tidyselect.r-lib.org/reference/select_helpers.html) for other `select()` helper functions). 

The `last_col()` function allows us to select either the last column, or with a specified offset we can select a number of columns before the last column. Thus, 2 columns before the last column  would be `last_col(offset = 2)` and then the `:` symbol is interpreted as through, thus we are selecting for the third to last column through the last column with `last_col(offset = 2):last_col()`.

```{r}
shooting_data_geocoded %>% 
  select(tidyr::last_col(offset = 2):last_col()) %>% 
  slice_head(n = 4)
```

Great! That looks like we expected. We can see that the coordinate values are slightly different now.

```{r}
original_shooting_data_geocoded <- read_csv(here("processed_data",
              "shooting_data_geo.csv"))

original_shooting_data_geocoded %>%
  select(longitude, latitude) %>% 
  slice_head(n = 4)
```

AVOCADO: in my knitted html, the first 4 lat/long rows were identical between old and new dataset? Should we use a `set.seed()`? 

Finally, we save our wrangled data, again using `write_csv()`.

```{r, eval = FALSE}
readr::write_csv(shooting_data, 
                 path = here("processed_data",
                             "shooting_data_pre_geo_wrangled.csv"))

write_csv(shooting_data_geocoded, 
          path = here("processed_data",
                      "shooting_data_wrangled.csv"))
```


# **Data Analysis and Visualization**
*** 

First let's load the data by reading in our wrangled version of the data.

```{r}
shooting_data <- 
  read_csv(here("processed_data",
                "shooting_data_pre_geo_wrangled.csv"))

shooting_data_geocoded <- 
  read_csv(here("processed_data",
                "shooting_data_wrangled.csv"))
```


There are several elements we would like to include in our dashboard. 

One thing we would like is an interactive table.

## Interactive Table

We can do this using the `datatable()` function of the `DT` package.

```{r, eval = FALSE}
DT::datatable(shooting_data)
```
This creates a searchable table and the order in which the data is displayed can be toggled to change for each variable.

However, we have many variables or columns in our dataset, so this can be overwhelming. Instead of displaying all of the variables, let's choose only some of the most interesting to display in our dashboard.

```{r}
DT_table <- 
  shooting_data %>%
  dplyr::select(Date,
                School,
                City,
                State,
                `Killed (includes shooter)`,
                `Narrative (Detailed Summary/ Background)`) %>%
  rename("Deaths" = `Killed (includes shooter)`) %>%
  rename("Narrative" = `Narrative (Detailed Summary/ Background)`)

DT::datatable(DT_table)
```

Next, we will maake some data visualizations. 


## Yearly Shootings

We would like to create a plot of the number of shootings per year.

To do this, we will first count the number of shootings per year by using the `group_by()` function and the `count()` function of the `dplyr` package. The `group_by()` functions allows us to summarize the data across specific groups specified by a variable or multiple variables. Specifically, we will group by the `Date_year` variable. 

**Note**: After `group_by()`, we need to use the `ungroup()` function to get the data out of this grouping based on the `Data_year` variable.

```{r}
shootings_per_year <- 
  shooting_data %>%
  group_by(Date_year) %>%
  count() %>%
  rename("Shootings" = n) %>%
  ungroup()

shootings_per_year
```
Good, this looks as expected.

Now to make a plot of this data we will use the `ggplot2` package.

***
<details><summary> Click here for an introduction about this package for more information on using `ggplot2` </summary>

The [ggplot2 package](http://ggplot2.tidyverse.org) is generally intuitive for beginners because it is based on a  [grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html) or the `gg` in `ggplot2`. 
The idea is that you can construct many sentences by learning just a few nouns, adjectives, and verbs. There are specific “words” that we will need to learn and once we do, you will be able to create (or “write”) hundreds of different plots.

The critical part to making graphics using `ggplot2` is the data needs to be in a _tidy_ format. 
Given that we have just spent time putting our data in _tidy_ format, we are primed to take advantage of all that `ggplot2` has to offer! 

We will show how it is easy to pipe _tidy_ data (output) as input to other functions that create plots. 
This all works because we are working 
within the _tidyverse_. 

**What is the `ggplot()` function?** 
As explained by Hadley Wickham:

> The grammar tells us that a statistical graphic is a mapping from data to aesthetic attributes (colour, shape, size) of geometric objects (points, lines, bars). The plot may also contain statistical transformations of the data and is drawn on a specific coordinates system.

`ggplot2` Terminology: 

- **ggplot** - the main function where you specify the dataset and variables to plot (this is where we define the `x` and
`y` variable names)
- **geoms** - geometric objects
    - e.g. `geom_point()`, `geom_bar()`, `geom_line()`, `geom_histogram()`
- **aes** - aesthetics
    - shape, transparency, color, fill, line types
- **scales** - define how your data will be plotted
    - continuous, discrete, log, etc

The function `aes()` is an aesthetic mapping function inside the `ggplot()` object. 
We use this function to specify plot attributes (e.g. `x` and `y` variable names) that will not change as we add more layers.  

Anything that goes in the `ggplot()` object becomes a global setting. 
From there, we use the `geom` objects to add more layers to the base `ggplot()` object. 
These will define what we are interested in illustrating using the data.

</details>

***

For more of an introduction on creating plots with `ggplot2` , see this [case study]()

AVOCADO: missing link to the case study above.

***

First, we start with the `ggplot()` function of the `ggplot2` package.

This function requires that the aesthetics `aes()` be specified. This involves choosing what variable will be plotted on the x-axis and the y-axis. 

```{r}
shootings_per_year %>%
    ggplot(aes(x = Date_year, y = Shootings))
```

Using the `ggplot()` function alone will create an empty plot area. To make our plot not empty, we need to select one of the `geom_*` functions of the `ggplot2` package to specify what type of plot we want to create.

Assuming the `ggplot2` library is loaded, type `geom` into the RStudio console and you will see many options to scroll through.

Here, we use a `geom_col()` plot, which is a particular type of bar plot that uses the actual values to plot, rather than counts, which is the default of `geom_bar()`. We will specify with the `fill` argument, that we want our bars to be filled with the color black.

```{r}
shootings_per_year %>%
    ggplot(aes(x = Date_year, y = Shootings)) +
    geom_col(fill = "black")
```

We also modify the x-axis using the `scale_x_continuous()` function. This function allows for specification of the range or limits of the axis using the `limits` argument. We can use the base `seq()` function to create a sequence of numbers for each tick mark.

We can add labels to our plot using the `labs()` function of `ggplot2`. This has arguments such as `x` and `y` for the axes and `title` and `subtitle` for titles. We can use `NULL` to remove a label. For example to remove the x-axis label we can use `x = NULL`

We will also modify the overall aesthetics of the plot using a `theme_*` function. See [here](https://ggplot2.tidyverse.org/reference/ggtheme.html) for a list of options.

```{r}
start <- 1970
end <- 2020

shootings_per_year_p <- 
  shootings_per_year %>%
    ggplot(aes(x = Date_year, y = Shootings)) +
      geom_col(fill = "black") +
      scale_x_continuous(breaks = seq(start, end, by = 5),
                         labels = seq(start, end, by = 5),
                         limits = c(start-1, end+1)) +
      theme_minimal() +
      labs(title = "Yearly School Shootings",
           subtitle = "United States",
           x = NULL,
           y = "School Shootings")

shootings_per_year_p 
```

## Yearly Deaths

Let's make a similar plot for the number of deaths

```{r}
deaths_per_year<-
  shooting_data %>% 
  group_by(Date_year) %>%
  summarize(Deaths = sum(`Killed (includes shooter)`))

deaths_per_year_p <- 
  deaths_per_year %>%
    ggplot(aes(x = Date_year, y = Deaths)) +
      geom_col(fill = "black") +
      scale_x_continuous(breaks = seq(start, end, by = 5),
                         labels = seq(start, end, by = 5),
                         limits = c(start-1, end+1)) +
      theme_minimal() +
      labs(title = "Yearly Deaths Attributable to School Shootings",
           subtitle = "United States",
           x = NULL)

deaths_per_year_p
```

**Note**: When using the `summarize()` function, we don't use the `mutate()` function here.

Next, for the purposes of the dashboard, we actually want to create just one plot that shows both the number of shootings per year and the number of deaths.

We can do so by combining our `shootings_per_year` and  `deaths_per_year` tibbles together and making what is called a faceted plot, using the `facet_wrap()` function to create two plots next to one another.

To combine our data we will use the `full_join()` function of the `dplyr` package. This maintains all values from both tibbles.

To do so we will be making our table "longer", meaning that it will have fewer columns and more rows. 
See [here](https://en.wikipedia.org/wiki/Wide_and_narrow_data) for more information about different table formats, typically referred to as wide and long or sometimes narrow.

We will use the `pivot_longer()` function of the `tidyr` package to change the shape of our table. 

There are 3 main arguments in this function:   

1. `cols` - which specifies what columns to collapse  
2. `names_to` - which specifies the name of the new column that will be created that will contain the column names of the columns you are collapsing  
3. `values_to` - which specifies the name of the new column that will be created that will contain the values from the columns you are collapsing 

To specify that we want to collapse all the columns that have year values, we can choose all those except the `Date_year` variable by using the `-` negative operator. 

```{r}
per_year <- 
  full_join(shootings_per_year, deaths_per_year)

per_year %<>%
  pivot_longer(cols = -Date_year, 
               values_to = "events", 
               names_to = "id")

per_year
```

Hmmm, we see the data type of the `id` column is a character (`<chr>`). Let's convert it to a factor, so that the the order in which `Shootings` and `Deaths` appear is the order in which they appear first rather than by alphabetical order (which is default).

Using the `fct_inorder()` function of the `forcats` package, we can easily reorder the `id` variable`. 

```{r}
per_year %<>% 
  mutate(id = forcats::fct_inorder(id))

per_year
```

Now since we the new variable for the names is called `id` we will use this as the variable to create the facet like so: `facet_wrap(~id)`. We can also specify that we want both plots to have their own y-axis with the `scales = "free"` argument. This causes each to have the y-axis automatically scaled for the data in each plot. We can then use the  `scale_y_continuous()` function to set both of the y-axes to be the same. 

```{r}
per_year %>%
  ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col() +
    facet_wrap(~id, scales = "free") +
    scale_x_continuous(breaks = seq(start, end, by = 5),
                       labels = seq(start, end, by = 5),
                       limits = c(start-1, end+1)) +
    scale_y_continuous(breaks = seq(0, 120, by = 30),
                       labels = seq(0, 120, by = 30),
                       limits = c(0, 121))+
    theme_minimal() +
    labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = "Number of events",
         x = "Year")+
    scale_fill_manual(values = c("black", "black"))+
    theme(legend.position = "none", 
          legend.title = element_blank(),
          axis.text.x = element_text(angle = 90),
          strip.background =element_rect(fill="cornflowerblue"),
          strip.text = element_text(colour = 'white', face = "bold", size = 14))
```

Next, we can modify the plot further so that it is more obvious what each plot is showing. We can update the names of the y-axis for each plot by changing the `strip.position` argument of the `facet_wrap()` function to be placed on the left rather than above. Currently it is the label in blue that says what the value of the `id` variable is for each plot. This also requires some modification of the `theme()` function to place the `strip.text` outside the plot area and to remove the background.Furthermore, we also change the text using the `labeller` argument of the `facet_wrap()` function. The `as_labeller()` function of the `ggplot2` package can change out the `id` values for other text like in the following code:

```{r}
per_year %>%
  ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col() +
    facet_wrap(~id, 
               scales = "free", 
               labeller = as_labeller(c(Shootings = "Shootings (# of events)", 
                                        Deaths = "Deaths (# of people)")), 
               strip.position = "left") +
    scale_x_continuous(breaks = seq(start, end, by = 5),
                       labels = seq(start, end, by = 5),
                       limits = c(start-1, end+1)) +
    scale_y_continuous(breaks = seq(0, 120, by = 30),
                       labels = seq(0, 120, by = 30),
                       limits = c(0, 121))+
    theme_minimal() +
    labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = NULL,
         x = "Year")+
    scale_fill_manual(values = c("black", "black"))+
    theme(legend.position = "none", 
          legend.title = element_blank(),
          axis.text.x = element_text(angle = 90),
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(face = "bold", size = 14))
```

Good,  Now this is much easier to interpret.

Our last step in this section is to save the style settings of this plot as theme so we can reuse it for future plots. To do this, we use the base `function()` function:

```{r}
theme_dashboard <- function(){ 
  theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90, face = "bold"),
        axis.title.x = element_text(face = "bold", size = 14),
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "bold", size = 14))
}
```



## Yearly Cumulative Shootings

Now let's make another plot of the cumulative deaths each year including those of the previous years. In this case we can use the `shooting_per_year` object that we previously made.

```{r}
shootings_per_year
```

However, we want to add a new variable using the `mutate` function called `n_cum_sum` by using the `cumsum()` function to calculate a cumulative sum based on the yearly count. 

```{r}
shootings_per_year_cum <- shootings_per_year%>%
    mutate(Shootings = cumsum(Shootings))

deaths_per_year_cum <- deaths_per_year%>%
    mutate(Deaths = cumsum(Deaths))

shootings_per_year_cum
```

Next, we join these tables together

```{r}
per_year_cum <- 
  full_join(shootings_per_year_cum, deaths_per_year_cum)

per_year_cum %<>% 
  pivot_longer(cols = c(Shootings,Deaths ), 
               values_to = "events", 
               names_to = "id")

per_year_cum
```

Good, this looks like we would expect.

Now let's make a plot like we did before:

```{r}
per_year_cum %<>% 
  mutate(id = forcats::fct_inorder(id))

per_year_cum %>%
    ggplot(aes(x = Date_year, y = events, fill = id)) +
      geom_col() +
      facet_wrap(~id, scales = "free", 
                 labeller = as_labeller(c(Shootings = "Shootings (# of events)", 
                                          Deaths = "Deaths (# of people)")), 
                 strip.position = "left") +
      scale_x_continuous(breaks = seq(start, end, by = 5),
                         labels = seq(start, end, by = 5),
                         limits = c(start-1, end+1)) +
      scale_y_continuous(breaks = seq(0, 1500, by = 500),
                         labels = seq(0, 1500, by = 500),
                         limits = c(0, 1500)) +
      theme_minimal() +
      labs(title = "Cumulative Yearly Shootings and Deaths\nAttributable to School Shootings",
           subtitle = "United States",
           y = NULL,
           x = "Year") +
      scale_fill_manual(values = c("black", "black")) +
      theme_dashboard()
```

**Note**: the limits for the y-axis were determined by first plotting without the `scale_y_continuous()` function.


## Deaths per Shooting

Next, we will make a plot of the number of deaths per shooting based on the `Killed (includes shooter)` variable. Our first plot could also have been made using `geom_bar()` instead of `geom_col()` this makes a similar plot but automatically uses the count for one of the axes. 

AVOCADO: maybe turn this into a learning opportunity with a question and answer? 

```{r}
# This is equivalent:
# deaths_per_event <- 
#   shooting_data %>%
#   group_by(`Killed (includes shooter)`) %>%
#   count() %>%
#   ungroup()
# 
# deaths_per_event %>%
#   ggplot(aes(y = `Killed (includes shooter)`, x = n)) +
#     geom_col(fill = "black")+
#     theme_minimal() +
#     labs(title = "Deaths per School Shooting",
#          subtitle = "United States",
#          x = "School Shootings",
#          y = "")

shooting_data %>%
  ggplot(aes(x = `Killed (includes shooter)`)) +
    geom_bar(fill = "black") +
    theme_minimal() +
    labs(title = "Deaths per School Shooting",
         subtitle = "United States",
         x = "School Shootings",
         y = "")
```

Because of the skewed distribution, it is difficult to see the shootings that had more numerous deaths, so we will add a facet that zooms in on this portion of the plot. We can do so, using the `facet_zoom()` function of the `ggforce` package.

```{r}
shooting_data %>%
  ggplot(aes(x = `Killed (includes shooter)`)) +
    geom_bar(fill = "black") +
    scale_x_continuous(breaks = seq(0, max(pull(shooting_data, 
                                    `Killed (includes shooter)`)), by = 1),
                       labels = seq(0, max(pull(shooting_data,
                                    `Killed (includes shooter)`)), by = 1)) +
    ggforce::facet_zoom(xlim = c(4, max(pull(shooting_data, 
                                    `Killed (includes shooter)`))), 
                        ylim = c(0,20)) +
    theme_minimal() +
    labs(title = "Deaths per School Shooting",
         subtitle = "United States",
         x = "Deaths per shooting",
         y = "Number of events with given number of deaths") +
  theme(axis.text.x = element_text(angle = 90))
```

It is still difficult to see. Let's try some other options.

The `geom_freqpoly()` function creates a graph that makes it very easy to see that most shootings result in zero or one death and that the maximum number of deaths in this data for a single event is in the upper twenties. 
```{r}
shooting_data %>%
    ggplot(aes(x = `Killed (includes shooter)`)) +
    geom_freqpoly()
```

This really shows that most shooting events luckily result in no deaths, but what are the actual proportions of shootings that end in 0 deaths, 1 death, 2 deaths, etc. 
One way to look at this is to calculate the percentage of events that resulted in each number of deaths. 
We can do this by dividing the number of events by the overall sum of events and multiplying by 100. 
The base `round()` function can round this value to the nearest 1 decimal place by specifying that we want 1 digit after the decimal with `digits = 1`.

```{r}
deaths_perc_event <-
  shooting_data %>%
  count(`Killed (includes shooter)`) %>%
  rename("num_events"= n) %>%
  mutate(percent = round(num_events/sum(num_events)*100, digits =1))

deaths_perc_event

deaths_perc_event %>%
  ggplot(aes(x =`Killed (includes shooter)`, y = percent)) +
    geom_col()
```

We can see that greater than 60% of the events had no deaths. It is however, the plot is still unsatisfactory because there is such a long tail.

Next, we can try collapsing the events that resulted in 4 or more deaths together and create a pie chart which you are likely familiar with as well as alternative plot called a waffle plot.

First to collapse the percentage for the events that had 4 or more deaths, we need to do a bit of wrangling.

We will start with filtering the data to only these events and then we will sum each of the columns using the base R function `colSums()` with the goal of creating a new row in the `deaths_perc_event` object that will contain information about all events with 4 or more deaths. We will use the `>=` greater than or equal to operator.

```{r}
greater_than4 <- 
  deaths_perc_event %>% 
  filter(`Killed (includes shooter)` >= 4) %>% 
  colSums()

greater_than4
```
Good, now we know the overall percentage for the events that unfortunately resulted in more than 4 deaths. 

Next, we combine this with the rest of our data using the `bind_rows()` function of the `dplyr` package which appends a tibble to another.

```{r, echo = FALSE, outwidth = "40%"}
knitr::include_graphics(here::here("img", "bindrows.png"))
```

##### [[source]](https://rstudio.com/resources/cheatsheets/)


```{r}
deaths_perc_event %<>%
  bind_rows(greater_than4)

deaths_perc_event 
```

Next, we add a new variable so that it is easy to plot and interpret the number of deaths for each percentage. 
We will add the word "deaths" to each value in the `Killed (includes shooter)` variable using the base `paste0()` function. Note that this function automatically will result in no space or any other character between pasted elements. The `paste()` function can alternatively be used for those cases. 

```{r}
deaths_perc_event %<>% 
  mutate(category = paste0(`Killed (includes shooter)`, 
                           " deaths ", "(", percent, "%)")) 

deaths_perc_event
```

We can change the value for the last row about the events that resulted in more than 4 deaths. 

We can use the `last()` function of the `dplyr` package combined with the `pull()` function to specifically grab this value.

```{r}
last(pull(deaths_perc_event, category))
```

Using the `case_when()` function, we can change this value. 

Note that we could have used a `stringr` function to replace the specific value of "85 deaths", but this would not be reproducible. Say we used this code again after the data got updated. Then there may be more deaths in this category and therefore this value would no longer be "85 deaths". Instead, by using `case_when()`, we can use an expression for the last value of the `deaths_perc_event` tibble and replace that, regardless of what the value is, with "4+deaths". Recall that `case_when()` replaces all other values that are not specified with `NA`. We do not want to lose the other values for the `category` variable. So to avoid this, we assign each of the values that are not the last value or the `"1 deaths"` value to what they currently are for the `category` variable, using `TRUE ~ category` (Note that all remaining unassigned values are indicated as `TRUE`).

AVOCADO: this sections seems like a good learning opportunity for Q and A

**Note**: we could actually type out the percentage of 4+death cases, but it is always more reproducible to instead use an expression that will evaluate to the value we want. This way if we were to update our data with additional shooting events, this evaluation would also update.

```{r}
deaths_perc_event %<>% 
  mutate(category =
           case_when(category == last(pull(deaths_perc_event, category)) ~ 
                        paste0("4+ deaths ", "(", percent, "%)"),
                     category == "1 deaths" ~ "1 death",
                     TRUE ~ category))

deaths_perc_event
```

Looks as we hoped. OK, now we are ready to make plots. 

Let's start with the pie chart. Historically, this has become a bit controversial type of plot. However, it can be very useful when you are actually looking at percentages and the goal is to see major trends in the data, such as all the groups are roughly equal or one group is particularly larger than the rest. When this is the case and you are presenting the data to an audience that is less familiar with data science, they may expect to see a pie chart. Thus it is useful to know how to make one. However, in most other cases pie charts do a poor job at allowing us to see more subtle differences, and they are particularly confusing when we are not looking at proportions, but raw counts. In those cases it is better to use a bar chart as we have already done. 

There is no `geom_*` function that allows you to create a pie chart directly. Instead we will create our bar plot as we have and then use the `coord_polar()` function to wrap our y axis into a circular shape.

```{r}
deaths_perc_event %>%
  filter(percent>0.5) %>%
  ggplot(aes(x = "", y = percent, fill = category)) +
      # adding color here adds a black outline
    geom_col(color = "black") +
    coord_polar("y", start = 0) +
    scale_y_continuous(breaks= NULL) +
    theme_minimal() +
    theme(axis.title = element_blank()) +
    scale_fill_viridis_d() +
    labs(title = "Percentages of school shooting deaths\n(including the shooter)")
```

This is actually a fairly easy plot to interpret. We can see that most events resulted in zero deaths and that the next largest proportion resulted in one death, while a sizable but small proportion resulted in two deaths. A very small proportion resulted in three or four or more deaths.

We also can create a waffle plot. This plot offers one advantage over the pie chart, in that it also allows for easier interpretation of more subtle proportion differences while also showing big picture differences in efficient manner. 

First, we filter for only the data that we want to plot. We only want the 0,1,2,3, or 4+ categories. We can do so by using the `str_detect()` function of the `stringr` package. This allows us to find the values that match multiple patterns. The patterns are separated by the `|` or operator. Thus any value matching any of the patterns should be kept. Notice that the `\\` is necessary before the `+` so that is not interpreted as a mathematical plus sign. 

The `waffle()` function requires that the data be in wide format. Thus we need to use `pivot_wider()` of the `tidyr` package to do so. This is very similar to the `pivot_longer()` function, however in this case we need to specify what existing column contains the names for the new columns using `names_from` and what existing column contains the values for the new columns using `values_from`. 

```{r}
deaths_perc_event %>% 
  select(-`Killed (includes shooter)`) %>%
  filter(str_detect(category, "0 deaths|1 death|2 deaths|3 deaths|4\\+")) %>%
  mutate(percent = round(percent)) %>%
  select(-num_events) %>%
  tidyr::pivot_wider(names_from = category, 
                     values_from = percent) %>%
  waffle::waffle(legend_pos = "bottom", title="Deaths Per School Shooting", 
                 xlab="1 square ~ 1%") +
  scale_fill_viridis_d()
```

### Percentages

Another thing we are interested in is to include statistics in our dashboard. For example, we are interested in how many shooters committed or attempted suicide.

AVOCADO: the next sentence seems incomplete? 

Since we converted variables with `yes` or `no` answers because they were inconsistently coded as `yes`/ `y` and `no`/`n`.  Furthermore, logical variables are easier to work with in terms of performing calculations because `TRUE` values are treated like a `1` while `FALSE` values are treated like a `0`. 

We can calculate the percentage of shooters that committed or attempted suicide out of all entries that have data for this information. Thus we do not want to include `NA` values in the calculation, otherwise this might give us a distorted picture of the truth.

Let's take a look at the data for this variable:

```{r}
shooting_data %>% 
  count(`Suicide (or attempted suicide) by Shooter (Y/N)`)
```

We can see that there are 45 `NA` values. 

If we calculate a sum of the `TRUE` values, (which are those that are equivalent to `1`), we can do so by just summing this variable, which is equivalent to summing values that are greater than `0`. 

```{r}
sum(pull(shooting_data, 
         `Suicide (or attempted suicide) by Shooter (Y/N)`), 
    na.rm = TRUE)
sum(pull(shooting_data, 
         `Suicide (or attempted suicide) by Shooter (Y/N)`) > 0, 
    na.rm = TRUE)
```

In contrast, `FALSE` values are those that are equivalent to `0`. Thus if we want to divide by the sum of all values that are `FALSE` are `TRUE`, then we can sum all values greater than or equal to `0`.

```{r}
sum(pull(shooting_data, 
         `Suicide (or attempted suicide) by Shooter (Y/N)`) >= 0, 
    na.rm = TRUE)
```

Thus, we can calculate the percentage of all reporting values like so, where the `TRUE` values are divided by the sum of all `TRUE` and `FALSE` values: (We also multiply by 100 using `*100` to get the percentage value.) 

```{r}
suicide <- 
  (sum(pull(shooting_data,`Suicide (or attempted suicide) by Shooter (Y/N)`), na.rm = TRUE) /
   sum(pull(shooting_data, `Suicide (or attempted suicide) by Shooter (Y/N)`)>=0, na.rm = TRUE))*100

suicide
```

We can use the `round()` function to round this value and the `format()` to make sure that the value has the correct number of digits. 

```{r}
suicide <- round(suicide, 1)
suicide
```

AVOCADO: we did get 13.4, right? not sure what you are saying below? 

If the rounded value is a whole number, the `format()` function allows the number of zeros to be displayed after the decimal to be specified. So say if we rounded the percentage to 2 decimal places and we got a value of  `13.4` (That is not the case here, so we will instead round to 1 decimal places for this illustration). We could then add a zero after the `4` like so:

```{r}
format(suicide, nsmall = 2)
```

To calculate the percentage of shootings where this information was reported we can do the following, by calculating all values that are not `NA` using `>=0` and calculating the number all possible values using the base `length()` function.

```{r}
reporting_suic <- 
  (sum(pull(shooting_data, 
            `Suicide (or attempted suicide) by Shooter (Y/N)`)>=0, 
       na.rm = TRUE) /
   length(pull(shooting_data, 
               `Suicide (or attempted suicide) by Shooter (Y/N)`))
   )*100

reporting_suic <- round(reporting_suic, 1)
reporting_suic
```

We can see that 97% of the shootings have information about this variable.

It is important to check and report this percentage so that people can better understand if our percentages are reliable. If only 2% of the shootings had this information and in all cases of the 2% the shootings involved a suicide (or attempt), then this would lead people to believe that 100% of school shootings involve a shooter suicide (or attempt). This would clearly be misleading!  In our case the majority of the shootings included this information, so we will indeed report the percentage and we will also let people know how much of the shooting data had this information.

You will see that we performed variations of these calculations to calculate other statistics for our dashboard.
For the sake of brevity, we will not include explanations here.

# **Dashboard Basics**
***

We are now ready to build our dashboard!

Let's introduce some basics about creating dashboards in R in the `flexdashboard` package.

## Dashboard packages
To make our dashboard we will use three very useful packages:

1. [flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/)

Flexdashboard is a package that was created by RStudio and [released](https://blog.rstudio.com/2016/05/17/flexdashboard-easy-interactive-dashboards-for-r/) in May of 2016. This package allows for users to more easily create dashboards using [R Markdown](http://rmarkdown.rstudio.com/). 

See [here](https://rstudio.com/resources/webinars/introducing-flexdashboards/) for a video about flexdashboard and [here](https://rmarkdown.rstudio.com/flexdashboard/) for a more information on how to use this package.

2. [leaflet](https://rstudio.github.io/leaflet/)

[Leaflet](https://leafletjs.com/) is the leading open-source JavaScript library for interactive maps and is used by many websites. The [leaflet](https://rstudio.github.io/leaflet/) R package allows for users to more easily integrate leaflet maps in R, to create maps like the one below. We will use this package to create a map of where school shootings have occurred in the US.

Here is an example of an interactive map made with `leaflet`

```{r,echo=FALSE}
library(maps)
mapStates = map("state", fill = TRUE, plot = FALSE)
leaflet(data = mapStates) %>% addTiles() %>%
  addPolygons(fillColor = topo.colors(10, alpha = NULL), stroke = FALSE)
```

3. [shiny](https://shiny.rstudio.com/)

[Shiny](https://shiny.rstudio.com/) is an R package that makes it easier to create interactive web applications in R. See [here](https://shiny.rstudio.com/gallery/) for a gallery of examples. People have created a variety of diverse applications using this package- from [interactive websites](https://shiny.rstudio.com/gallery/real-estate-investment.html) to [games](https://shiny.rstudio.com/gallery/hex-memory.html).

Here is an screenshot of a `shiny` app.

```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "game.png"))
```

##### [[source]](https://shiny.rstudio.com/gallery/hex-memory.html)

See [here](https://rmarkdown.rstudio.com/flexdashboard/using.html#components) for a list of other packages that are useful for adding elements to dashboards created with the `flexdashboard` package.

***

## R Markdown

The case study that you are reading right now was created using an [R Markdown document](https://rmarkdown.rstudio.com/). This means that it is a document that uses the `Markdown` language syntax with enhanced capabilities of executing R code in the document. 

In fact, if you click the button that says "code" on the upper right corner at the top of the HTML you will download the [R Markdown](https://rmarkdown.rstudio.com/articles_intro.html#:~:text=R%20Markdown%20is%20a%20file,code%2C%20like%20the%20document%20below.) document for this case study. 

[R Markdown (Rmd)](https://rmarkdown.rstudio.com/articles_intro.html#:~:text=R%20Markdown%20is%20a%20file,code%2C%20like%20the%20document%20below.) is a file format that contains Markdown syntax and embedded R code (it can also incorporate code from some other languages like [Python](https://en.wikipedia.org/wiki/Python_(programming_language)) and [SQL](https://en.wikipedia.org/wiki/SQL)).

```{r}
library(vembedr)
embed_url("https://vimeo.com/178485416") %>%
  div(class = "vembedr") %>%
  div(align = "center")
```

##### [[source]](https://rmarkdown.rstudio.com/lesson-1.html) 

AVOCADO: maybe a brief sentence about `vembedr`?

These Rmd files can be rendered into a variety of file outputs like PDF, word, HTML etc. by the  [`knitr`](https://yihui.org/knitr/) and [`rmarkdown`](https://cran.r-project.org/web/packages/rmarkdown/rmarkdown.pdf) packages.

This relies on conversion of the Rmd file into the [Markdown](https://en.wikipedia.org/wiki/Markdown) language by software called [Pandoc](https://en.wikipedia.org/wiki/Pandoc).

[Markdown](https://en.wikipedia.org/wiki/Markdown) (which has been implemented by many languages, such as [Perl](https://en.wikipedia.org/wiki/Perl), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)), etc.) is a language of a particular class of programming languages called [lightweight markup languages (LML)](https://en.wikipedia.org/wiki/Lightweight_markup_language). 

LMLs have relatively simple and intuitive syntax, and are therefore relatively easy to write and read and are converted by software into some type of less human-friendly language to create an output document like a PDF or an HTML file. In fact, multiple output files can be created from the same LML file!

In our case we are interested in rendering our Rmd document into a website. The code in our R Markdown document will be interpreted and converted ultimately into HTML code.

Although LMLs tend to be quite similar, here you can see some of the differences in syntax:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "syntax.png"))
```

##### [[source]](https://en.wikipedia.org/wiki/Lightweight_markup_language)

See this [book](https://bookdown.org/yihui/rmarkdown/) for more information on working with R Markdown files. 

The RStudio [cheatsheet for R Markdown](https://github.com/rstudio/cheatsheets/raw/master/rmarkdown-2.0.pdf) and this [tutorial](https://ourcodingclub.github.io/tutorials/rmarkdown/) are great for getting started. 

## Flexdashboard

There are several important features about the R Markdown language that the `flexdashboard` package leverages. 

These features are used to specify the layout and elements of the dashboard.

Here are some major R Markdown features to keep in mind for `flexdashboard`:

1. The beginning of an R Markdown document is what is called the [YAML](https://en.wikipedia.org/wiki/YAML) header. This is delineated by `---` three dash marks before and after the header YAML code.

Like so:
```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "yaml.png"))
```

##### [[source]](https://ourcodingclub.github.io/tutorials/rmarkdown/)

[YAML](https://en.wikipedia.org/wiki/YAML) is yet another language, but unlike Markdown it is a data-oriented language and is often used for the [configuration](https://en.wikipedia.org/wiki/Configuration_file) of software or to set up how a software program should work.

Whatever code you put in the YAML header will influence the rest of the document and essentially set up how the R Markdown document will render. In the example above, the type of output is specified.

Other more complicated features can be included. For example, we can specify that we are creating a dashboard with `flexdashboard` and we can specify how we want the layout of our dashboard to be displayed like so:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "yaml_dashboard.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

We will describe this in more detail soon.

2. To add a page to a navigation bar (also called a navbar) the following syntax is used `=======`. The number of dashes does not matter. (This is a level 1 header in Markdown, just like `#`)

3. To add columns or rows the following syntax is used `---------`. By default this notation will create new columns, however if the YAML is modified to specify to create rows, than this same syntax will be used to create rows. The number of dashes does not matter. (This is a level 2 header in Markdown, just like `##`)

4. Components within the dashboard are delineated by using `###` - if you are familiar with Markdown notation, this is a level 3 Markdown header.

If this includes text like so: `### text`, this adds header text to the component, however this is not required. 


5. To  include a plot or any output from R, use the following syntax:
`"```{r}"` on it's own line followed by your code, followed by `"```"`. This creates what is called a code chunk.

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "code_chunk.png"))
```

##### [[source]](https://ourcodingclub.github.io/tutorials/rmarkdown/)

6. Another component of `flexdashboard` is value boxes. These are essentially text boxes for statistics or text that youmight like feature or emphasize. To do this again the `###` syntax is used to put a text label describing what the value box contains followed by a code chunk that uses the `valueBox()` function of the `flexdasboard` package. The value to display is specified using the `value` argument, as well as optional other aspects using additional arguments, such as the color of the value box using the `color` argument like the example below:

```
### ValueBoxText

'''{r}
valueBox(value = 10
  color = "white")

'''
```

**Note**: in our examples of code we will use `"'''"` instead of `"```"`. This is only to allow for easy viewing of examples. All code chunks require `"```"`.

Here you can see a more thorough example which includes icons:
```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "valuebox.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/using.html#value_boxes)

7. Instead of value boxes you can also include a slight variation called a gauge. These are created with the `guage()` function of the `flexdashboard` package. This requires numeric values for a `value`, a `min`, and a `max` argument. Optionally, a symbol can also be added with the `symbol` argument. The value argument does not have to be explicitly called though, which is also true of the `valueBox()` function.

Here is a simple example:

```
### GuageText

'''{r}
flexdashboard::gauge(value = 10, 
                       min = 0, 
                       max = 100, 
                    symbol = "%")

'''
```

This creates the following output:
```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "gauge_output.png"))
```

Here is a more complicated example:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "gauge.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/using.html#value_boxes)

## Layout

### Adding Columns

To add multiple columns the following syntax is used `---------` for each  column and nothing additional is required in the header.

Additional features about the columns, such as the width can be specified using brackets`{}`like in the example below. Note that the word `Column` isn't necessary. In this example two columns are created that will be oriented next to one another and elements within the columns will be placed top to bottom. 

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "columns.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)


### Adding Rows
To add multiple rows - the yaml needs to state that the orientation is for rows instead of for columns (see the image below),  and then the same syntax is used `---------`  for each row instead of columns. In this example, two rows are created that will be oriented on top of one another and elements within the rows will be placed next to each other.

Again the word `Row` is not actually necessary.

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "rows.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

See [here](https://rmarkdown.rstudio.com/flexdashboard/layouts.html) for template options.


### Tabs

To add tabs columns/rows we can use the following: 

```
Column {.tabset}
```

In this example, two columns are created and then two tabs are added to the second column.

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "tab.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

### Shiny

Interactive elements can be added to dashboards. In our dashboard, we will use packages such as `DT` and `leaflet` that have shiny functionality. This requires that shiny is enabled in the YAML header by including `runtime:shiny` in the YAML.

Here is an example of a YAML that includes this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "shiny_yml.png"))
```

***

# **Our Dashboard**
***

OK! Now that we know a bit about the basics of creating a dashboard, let's create our own.

We want to create a dashboard that has several tabs that will look like this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "dashboard_school.png"))
```

## Getting started

The first thing we need to do to create our dashboard is to create a new .Rmd document like so in R Studio:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "newrmd.png"))
```


## YAML header

Next we need to update the YAML header to look like this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "our_yaml.png"))
```


As you might expect, `title:` indicates the title of our dashboard.

The `output:` line specifies what type of output we want the .Rmd file to be rendered.

We need to include `flexdashboard::flex_dashboard:` as the output to create a dashboard with the `flexdashboard` package. This can be included on the same line as `output:` or on the next line with a preceding tab.

**Note**: that YAML is sensitive to spacing, thus this tab is required to get the proper output.

The next four lines are arguments for how the dashboard should be created.

1. `logo:` allows you to include a logo on top of your dashboard. With this theme this will be in the upper left corner. The logo we chose to use came from [here](https://iconarchive.com/), but you could theoretically use any png of appropriate size.

2. `theme:` allows you to specify how the dashboard will look in general. Note that this can be used to modify the general look of any type of R Markdown output, not just dashboards created with `flexdashboard`. See [here](https://www.datadreaming.org/post/r-markdown-theme-gallery/) for a list of options. In our case, the theme is called readable and will create documents that look like this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "readable.png"))
```

##### [[source]](https://www.datadreaming.org/post/r-markdown-theme-gallery/)

3. `orientation:` the options are `columns` or `rows` and specifies if the `--------` syntax creates rows or columns for the layout. This is not necessary if the option is `columns`.

4. `source_code:` specifies if a URL will be included as a navigation bar item with access to the source code. 

5. `vertical_layout:` The options are `fill` or `scroll`. Fill causes the charts to re-size to fill the page, while the scroll option renders plots as their natural height which may or may not require scrolling the page.

There are many other argument options for how the dashboard is displayed.

You can run the following command in the console to see more information about the arguments in the help pane of the R Studio [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment).

```{r}
?flexdashboard::flex_dashboard()
```

Also see the CRAN [documentation](https://cran.r-project.org/web/packages/flexdashboard/flexdashboard.pdf) for more details.

## Loading the packages and data

Since we are creating our dashboard in a new Rmd file, we need to load the necessary packages and the wrangled data that we created in this Rmd file. In that Rmd file, it looks something like this. 

**Note**: all the following code would be **added to the Rmd file for the dashboard** and are simply shown here for illustrative purposes.

```{r,eval = FALSE}
library(here)
library(readr)
library(dplyr)
library(flexdashboard)
library(shiny)
library(magrittr)
library(forcats)
library(stringr)
library(waffle)
library(tidyr)
library(poliscidata)
library(leaflet)
library(htmltools)
library(DT)
```

For more information about what these packages were used for, see the beginning of this case study and the [Helpful Links] section.

```{r,eval = FALSE}
shooting_data <- 
  read_csv(here("processed_data",
                "shooting_data_pre_geo_wrangled.csv"))

shooting_data_geocoded <- 
  read_csv(here("processed_data",
                "shooting_data_wrangled.csv"))
```


## Creating pages

Recall that `===` is used to designate elements that are part of the navigation bar.

We want 7 items besides the source code (which was added automatically based on the YAML code).

First, we create 7 divisions for these main pages. We add icons to each from [Font Awesome](https://fontawesome.com/icons?d=gallery).

Use this [link](https://fontawesome.com/icons?d=gallery) to find other icon options. If you click on the "start using this icon" button it will take you to a page with HTML code like this:  

```{r, echo = FALSE, out.width="60%"}
knitr::include_graphics(here::here("img", "fontawesome.png"))
```

#### [[source]](https://fontawesome.com/icons/database?style=solid)

Onlythe `fa-database` portion is required in the brackets after `data-icon=` to add the icon to the navigation bar.

```

About {data-icon="fa-question-circle"}
====================================

The Data {data-icon="fa-database"}
===================================== 

US Statistics {data-icon="fa-flag"}
=====================================

State Statistics {data-icon=fa-flag-checkered}
====================================

Map {data-icon="fa-map"}
====================================

Tutorial {.storyboard data-icon="fa-list-ol"}
====================================

Hotline {data-icon="fa-exclamation-triangle"}
====================================

```

## The About Page

Here, we create content in the About page.

### Look

This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "aboutpagelook.png"))
```

### Overall Structure

Here is the overall structure for this page:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "about_page_structure.png"))
```

### Details

***
<details> <summary> Click here if you would like to see all of the code for this page. </summary>

On this page we will have two columns - one which will be wider than the other.  Size specifications on `flexdashboard` are unit-less; the width of any column included on a page is a function of the width set for a column against the sum of widths for all columns on that page. If we set columns sizes of 600 and 300 on a page with two columns, one column will be twice as large as the other column. We want the left column to be quite a bit larger than the right, so we will set the left as `70` and the right as `30`.

We will start out like so:

```
About {data-icon="fa-question-circle"}
===================================== 

Column {data-width = 70}
-------------------------------------

###

Column {data-width = 30}
-------------------------------------

###

```

Recall that `###` is used to add elements to columns and rows. Note that there is no text next to the `###` syntax that designates an element of our dashboard. In the previous examples, a header was used like so `### header`:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "tab.png"))
```

[[source](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)]

avocado if we add `###` for the source like usual, then we will no longer have the subsequent headers following the details section

We do no actually want a header now, so we can simply use `###` without any text following it. Note that you can get away with not using the `###`, but some elements will not render properly. 

Next, we add a block of text describing the dashboard to the first column and we will add an image to the second column like the following. Notice that two asterisks `**` around text makes them appear as bold and one `*` makes it appear as italic. See [this RStudio cheatsheet](https://rmarkdown.rstudio.com/lesson-15.html) for some basic Markdown syntax for stylizing text:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "markdownsyntax.png"))
```

[[source](https://rmarkdown.rstudio.com/lesson-15.html)] 

avocado if we add `###` for the source like usual, then we will no longer have the subsequent headers following the details section

This is what the code for this page looks like (notice that there is an internal link to the `Tutrial` page):

```
About {data-icon="fa-question-circle"}
===================================== 

Column {data-width=70}
-------------------------------------

### 

**What is the purpose of this dashboard?**

This dashboard has two purposes:

1. To illustrate trends in school shooting events in the United States
2. To demonstrate how to create a dashboard using `R`

**The data**

This dashboard uses data from the open-source [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) downloaded from the [Center for Homeland Defense and Security](https://www.chds.us/c/) at the at the [Naval Postgraduate School(NPS)](https://en.wikipedia.org/wiki/Naval_Postgraduate_School). This data was downloaded June of 2020.

<style>
div.green { background-color:#8FBC8F; border-radius: 5px; padding: 20px; font-size: 1em;color: white;}
</style>
<div class = "green">
Riedman, David, and Desmond O’Neill. “CHDS – K-12 School Shooting Database.” Center for Homeland Defense and Security, June 2020, [www.chds.us/ssdb](www.chds.us/ssdb).
</div>


  
This database includes information about school shooting events for students in grades K-12 in the United States dating back to 1970. The database has additional information not shown on our dashboard including, but not limited to: location of the event at the school, source for the shooting information, shooter characteristics, and victim characteristics. 

### 


<u>**Want to learn how to create a dashboard just like this?**</u>

Visit the [*Tutorial*](#tutorial) page of this dashboard to first learn the basics about building a dashboard with the `flexdashboard` package.

At the end of the tutorial we provide a link to this [supplementary resource by the Open Case Studies project](INCLUDE LINK HERE), which provides more detailed information about how ***this dashboard*** was created.

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px; font-size: .8 em;}
</style>
<div class = "blue">

 **Acknowledgements**

This was created as part of the [Open Case Studies](https://opencasestudies.github.io){target="_blank"} project. We would like to acknowledge the [Bloomberg American Health Initiative](https://americanhealth.jhu.edu/) for funding this work. 

 **Disclaimer**

This dashboard uses data from the [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/). We acknowledge (like their website) that there may be reporting errors. The trends and statistics shown do not account for the many other factors that may influence the occurrence of shooting events. The dashboard should not be used in the context of making policy decisions without external consultation from scientific experts. 


 **License**

This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 [(CC BY-NC 3.0)](https://creativecommons.org/licenses/by-nc/3.0/us/){target="_blank"} United States License.
</div>

Column {data-width=30}
-------------------------------------

###


'''{r, echo=FALSE, fig.cap="[Photograph by Nathan Dumlao](https://unsplash.com/photos/xPHmmVKS8lM)"}
knitr::include_graphics(here::here("img", "nathan-dumlao-xPHmmVKS8lM-unsplash.jpg"))
'''
```

Note that we will use `"'''"` for to show code chunks of the actual code from the dashboard.

The image used in this second column is from a website called unsplash (https://unsplash.com/) which hosts images for free use but includes information about the photographer if you chose to credit them. A short link for this image was found by clicking on it and then clicking the share button.

Notice the `echo = FALSE` specification for the code chunk which causes the code to be evaluated but but not shown, while `fig.cap` adds the figure caption.

The image is included using the `include_graphics()` function of the `knitr` package. We need to specify where this image is located for this to work. You can do this without specifying a path if the image file is in the same directory as your `.Rmd` file that you are using to create your dashboard. However using the `here()` function of the `here` package we can organize our files a bit. This function will automatically start the path wherever we have included an RStudio project file, this can be done in RStudio like so:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "project.png"))
```

If you are new to using RStudio projects, please see this [link](https://r4ds.had.co.nz/workflow-projects.html) for more information.

Then if we create a directory or folder called `img` and place our image files in this directory, then we can specify the full path to this file on our computer, by just using `here::here("img", "name_of_image.png")`. The `include_graphics()` function works for a variety image file types. 

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "newdir.png"))
```

Also you may have noticed the  `<style>` html code to add a blue and green background to portions of the text. 

The text that we want altered with this particular style is delineated by the `<div>` to start and the `</div>` to end the style. 

Let's take a look at the first one to explain what is happening here:

```
<style>
div.green { background-color:#8FBC8F; border-radius: 5px; padding: 20px; font-size: 1em; color: white;}
</style>
<div class = "green">
Riedman, David, and Desmond O’Neill. “CHDS – K-12 School Shooting Database.” Center for Homeland Defense and Security, June 2020, [www.chds.us/ssdb](www.chds.us/ssdb).
</div>
```

The instructions for the style are within the `<style>` and `</style>` content dividers. Inside these dividers is [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) code, which is what is used to stylize HTML. The `div.green` is the name of this particular style which involves a particular background color (#8FBC8F - see [here](https://www.w3schools.com/cssref/css_colors.asp) for more options), with a boarder radius of 5 pixel to round the edges of the background color around the text with a size 5 pixel radius. The code also states that a [padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding) specification for the size of the margins of the text box around the text and it specifies that font should be of 1 [em units](https://www.w3.org/Style/Examples/007/units.en.html) (which stands for element - thus 1 unit relative to the size of the element)  and that the font should be white.  

The `div.green ` specifies that `green` is the name of this style, thus we can then use `<div class = green>` (called a [CSS selector](https://developer.mozilla.org/en-US/docs/Glossary/CSS_Selector)) to style the text this way. This can then be used again any time we want this style like so:

```
<div class = "green">

text 

</div>

```

See this [website](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div) to learn more about HTML and CSS.

</details>

***

## The Data Page (Interactive)

Let's create a page about the data that we are using.

### Look


This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "The_Data_Page.png"))
```

### Overall Structure
Here is the overall structure for this page:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "Data_page_structure.png"))
```

### Details

***
<details> <summary> Click here to see the code for this page. </summary>
 
To create the structure for this page that will display the data, we have two columns, with the first one (on the left) wider than the other. Again we have a block of text in the column on the left like so:

```
The Data {data-icon="fa-database"}
===================================== 


Column {data-width=70}
-------------------------------------

###

The data used in this dashboard is from the [**Center for Homeland Defense and Security (CHDS)**](Center for Homeland Defense and Security (CHDS)) [**K-12 Shool Shooting Database**](https://www.chds.us/ssdb/dataset/). 

Their methods for identifying and authenticating incidents are outlined [here](https://www.chds.us/ssdb/methods/).

According to their website: 

*"The database compiles information from more than 25 different sources including peer-reviewed studies, government reports, mainstream media, non-profits, private websites, blogs, and crowd-sourced lists that have been analyzed, filtered, deconflicted, and cross-referenced. **All of the information is based on open-source information and 3rd party reporting... and may include reporting errors.**"*

***


Column {data-width=30}
-------------------------------------

###

```

Now we will add our `DT_table` to the first column. First, we need to include the code that we previously used to create the `DT_table` in our dashboard `.Rmd` file:

```{r, eval = FALSE}
DT_table <- shooting_data%>%
  dplyr::select(Date,
                School,
                City,
                State,
                `Killed (includes shooter)`,
                `Narrative (Detailed Summary/ Background)`) %>%
  rename("Deaths" = `Killed (includes shooter)`) %>%
  rename("Narrative" = `Narrative (Detailed Summary/ Background)`)
```

We then include some code to render this interactive table in our dashboard. Since we have `shiny` enabled in our YAML header, we can use the `renderDataTable()` of the `DT` package to produce the output we desire. 

We also want to use the `options` argument to specify how the data is rendered. The `scroller = TRUE` argument adds a scroll bar to the table, the `scrollY` argument specifies that the scroll bar should be for they Y axis direction (up and down) of the table and specifies how large the scroller should be, the `pageLength` argument specifies how many rows should be displayed simultaneously within the table, and the `autoWidth = TRUE` argument specifies that the table should fit the space of the column or page it is within. 

We will also add a caption with a link to the original data using the `tags()` and `withTags()` functions of the `htmltools` package. Different options for types of tags can be selected using the `$`.

```{r, echo = FALSE, out.width="60%"}
knitr::include_graphics(here::here("img", "tags.png"))
```

```{r, eval=FALSE}
DT::renderDataTable({
  DT::datatable(DT_table,
                caption = htmltools::tags$caption(
                  style = 'caption-side: top; text-align: Left;',
                  htmltools::withTags(
                    div(HTML('<a href="https://www.chds.us/ssdb/dataset/)">Click here to be redirected to a page where this data can be downloaded.</a>')))),
                  options = list(autoWidth = TRUE,
                                 pageLength = 10,
                                 scroller = TRUE,
                                 scrollY = '450px'))
})
```

We will also add another image to the column on the right, overall the code looks like this:

```

The Data {data-icon="fa-database"}
===================================== 

Column {data-width=70}
-------------------------------------

###

The data used in this dashboard is from the [**Center for Homeland Defense and Security (CHDS)**](Center for Homeland Defense and Security (CHDS)) [**K-12 Shool Shooting Database**](https://www.chds.us/ssdb/dataset/). 

Their methods for identifying and authenticating incidents are outlined [here](https://www.chds.us/ssdb/methods/).

According to their website: 

*"The database compiles information from more than 25 different sources including peer-reviewed studies, government reports, mainstream media, non-profits, private websites, blogs, and crowd-sourced lists that have been analyzed, filtered, deconflicted, and cross-referenced. **All of the information is based on open-source information and 3rd party reporting... and may include reporting errors.**"*

***

'''{r, echo=FALSE}
# Create the DT table first
DT_table <- shooting_data %>%
  dplyr::select(Date,
                School,
                City,
                State,
                `Killed (includes shooter)`,
                `Narrative (Detailed Summary/ Background)`) %>%
  rename("Deaths" = `Killed (includes shooter)`) %>%
  rename("Narrative" = `Narrative (Detailed Summary/ Background)`)
# Instead of depending on the st_jitter algorithm to generate random placement, a custom function placing the points side by side at a set distance could be used to make points occuring at the same location appear neatly apart.
'''

'''{r, echo=FALSE}
DT::renderDataTable({
  DT::datatable(DT_table,
                caption = htmltools::tags$caption(
                  style = 'caption-side: top; text-align: Left;',
                  htmltools::withTags(
                    div(HTML('<a href="https://www.chds.us/ssdb/dataset/)">Click here to be redirected to a page where this data can be downloaded.</a>')))),
                options = list(autoWidth = TRUE,
                               pageLength = 10,
                               scroller = TRUE,
                               scrollY = '450px'))
})
'''

Column {data-width=30}
-------------------------------------

###

'''{r, echo=FALSE, fig.cap="[Photograph by Rubén Rodriguez](https://unsplash.com/photos/IXTvnOOSTyU)"}
knitr::include_graphics(here::here("img", "ruben-rodriguez-IXTvnOOSTyU-unsplash.jpg"))
'''
```

</details>

***

## The US Statistics Page

Let's create a page for **US Statistics** we would like to share. 

### Look
This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "US_Statistics_page.png"))
```

### Overall Structure
Here is the overall structure for this page which uses a tab layout:

```{r, echo=FALSE, out.width="90%"}
knitr::include_graphics(here::here("img" , "US_stats_page_overview.png"))
```

avocado in the case of new mexico... the rounded values add up to 99 which creates an empty extra square only when using scale_fill_viridis_d()

### Details

***
<details> <summary> Click here to see the code for this page. </summary>

Here we use the `.tabset` and `.tabset-fade` options specified for our first column. 

```
US Statistics {data-icon="fa-flag"}
===================================== 


Column {data-width=70 .tabset .tabset-fade}
-------------------------------------
```

After having specified the `.tabset` and `.tabset-fade` options, we can create new tabs in the same way we would add elements to our dashboard with the `###` syntax. Just like in this example:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "tab.png"))
```

[[source](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)]


Let's make a tab for yearly shooting events and deaths, a tab for cumulative shooting events and deaths, and a tab about the number of deaths per shooting. In each tab, we will include the code for the plots that we have previously created. 

```
US Statistics {data-icon="fa-flag"}
===================================== 

Column {data-width=700 .tabset .tabset-fade}
-------------------------------------

### Yearly Deaths and Shootings

'''{r}

start <- 1970
end <- 2020

shootings_per_year<- shooting_data %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()

deaths_per_year<-shooting_data %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))


per_year<-full_join(shootings_per_year, deaths_per_year)
per_year %<>%pivot_longer( cols = (-Date_year), 
                           values_to = "events", 
                           names_to = "id")

per_year%<>% 
  mutate(id = forcats::fct_inorder(id))

per_year %>%
    ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_wrap(~id, scales = "free", 
               labeller = as_labeller(c(Shootings = "Shootings (# of events)", 
                                        Deaths = "Deaths (# of people)")), 
               strip.position = "left")+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    scale_y_continuous(breaks = seq(0, 120, by = 30),
                 labels = seq(0, 120, by = 30),
                 limits = c(0, 121))+
    theme_minimal() +
   labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = NULL,
         x = "Year")+
  scale_fill_manual(values = c("black", "black"))+
  theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90, face = "bold"),
        axis.title.x = element_text(face = "bold", size = 14),
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "bold", size = 14))


theme_dashboard <- function(){ 
  theme(legend.position = "none", 
        legend.title = element_blank(),
        #title = element_text(face = "bold", size = 16),
        axis.text.x = element_text(angle = 90, face = "bold"),
        axis.title.x = element_text(face = "bold", size = 14),
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "bold", size = 14))
}
'''

### Yearly Cumulative Deaths and Shootings

'''{r}
shootings_per_year_cum <- 
    shootings_per_year %>%
    mutate(Shootings = cumsum(Shootings))

deaths_per_year_cum <- 
    deaths_per_year %>%
    mutate(Deaths = cumsum(Deaths))

per_year_cum <- full_join(shootings_per_year_cum, deaths_per_year_cum)

per_year_cum %<>% 
  pivot_longer(cols = c(Shootings, Deaths ), 
               values_to = "events", 
               names_to = "id")

per_year_cum %<>% 
  mutate(id = forcats::fct_inorder(id))

per_year_cum %>%
  ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_wrap(~id, scales = "free", 
               labeller = as_labeller(c(Shootings = "Shootings (cumulative # of events)", 
                                        Deaths = "Deaths(cumulative # of people)")), 
               strip.position = "left")+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                       labels = seq(start, end, by = 5),
                       limits = c(start-1, end+1)) +
    scale_fill_manual(values = c("black", "black")) +
    theme_minimal() +
    labs(title = "Cumulative Yearly Shootings and Deaths Attributable to\nSchool Shootings",
         subtitle = "United States",
         y = NULL,
         x = "Year") +
    theme_dashboard() 
'''

### Deaths Per Shooting

'''{r}
deaths_perc_event <- 
   shooting_data %>%
   count(`Killed (includes shooter)`) %>%
   rename("num_events"= n) %>%
   mutate(percent = round(num_events/sum(num_events)*100, digits =1))

greater_than4 <- 
  deaths_perc_event %>% 
  filter(`Killed (includes shooter)` >= 4) %>% 
  colSums()

deaths_perc_event %<>% bind_rows(greater_than4)

deaths_perc_event %<>% 
  mutate(category = paste0(`Killed (includes shooter)`, " deaths ", "\n(", percent, "%)")) 

deaths_perc_event %<>% 
  mutate(category = case_when(
    category ==  last(pull(deaths_perc_event, category)) ~ paste0("4+ deaths ", "\n(", percent, "%)"),
    category == "1 deaths" ~ "1 death",
    TRUE ~ category))

deaths_perc_event %>% 
  select(-`Killed (includes shooter)`) %>%
  filter(str_detect(category, "0 deaths|1 death|2 deaths|3 deaths|4\\+")) %>%
  mutate(percent = round(percent)) %>%
  select(-num_events) %>%
  tidyr::pivot_wider(names_from = category, 
                    values_from = percent) %>%
  waffle::waffle(legend_pos = "bottom", title = "Deaths Per School Shooting", 
       xlab="1 square ~ 1%")+  scale_fill_viridis_d()

'''
```

In the second column, we will include what are called value boxes to contain statistics that will remain static as the user moves through the tabs of the first column.

```
Column {data-width=30}
------------------------------------- 
```

We want to display some important statistics, such as:

+ Total number of people wounded in a school shooting   
+ Total number of deaths from a school shooting  
+ Median number of shots fired  
+ Percentage of shootings where the shooter was the only victim  
+ Percentage of shootings where a single handgun was used  
+ Percentage of shootings where the shooter was male

To create a value box we will use the `valueBox()` function of the `flexdashboard` package. The text for the the value box is specified by the text following the `###` syntax.

There are a few arguments to be aware of for this function:

1. `value` - this is the value to be displayed in the box - this usually a number, but might be text
2. `caption` - if desired, you can add text to be displayed under the value but keep in mind that you will also include text with the `###` syntax
3. `icon` - if you would like to add an icon you can specify it like so: `icon = fa-flag`
4. `color` - this changes the color of the box
5. `href` - if you would like to add a URL link you can do so with this argument

We can create a value box for the total number of people wounded as follows, where we use the base `sum()` function to calculate the sum of all the values for the `Wounded` variable which was extracted using the `pull()` function of the `dplyr` package. We need to remove `NA` values to be able to calculate the sum and we can do this using the `na.rm = TRUE` argument. 


```
Column {data-width=300}
------------------------------------- 


### **Total Wounded**
    
'''{r}
valueBox(value = sum(pull(shooting_data, Wounded), na.rm = TRUE),
         color = "white")
'''
    
### **Total Deaths**

'''{r}
valueBox(value = sum(pull(
  shooting_data,`Killed (includes shooter)`), na.rm = TRUE),
         color = "white")
'''

```

To calculate the percentage of shootings where the shooter committed or attempted suicide, we will use our calculation which was explained in the [Data Analysis and Visualization] section. The `paste0` function is used to add the percentage symbol.

```

### **Shooter committed or attempted suicide**

'''{r}

suicide <- (sum(pull(shooting_data,`Suicide (or attempted suicide) by Shooter (Y/N)`), na.rm = TRUE) /
            sum(pull(shooting_data, `Suicide (or attempted suicide) by Shooter (Y/N)`)>=0, na.rm = TRUE))*100
suicide <- round(suicide, 1)

reporting_suic <- (sum(pull(shooting_data, `Suicide (or attempted suicide) by Shooter (Y/N)`)>=0, na.rm = TRUE)/
              length(pull(shooting_data, `Suicide (or attempted suicide) by Shooter (Y/N)`)))*100
reporting_suic <- round(reporting_suic, 1)

valueBox(value = paste0(suicide,"%"), 
         color = "white")
'''

```

For the value box of the percentage of shootings where a single handgun was used was calculated by using the `case_when()` function to specify all cases where the `Firearm Type` variable was equal to `"Handgun"` as `TRUE` and all others as `FALSE`. This allows us to use the base `sum()` function as `TRUE` values will be counted as a value of `1` and `FALSE` values will be counted as a value of `0`. This sum was then divided by the total number of shooting events by getting the length of the `Firearm Type` variable using the base `length()` function. The next value box about the gender of the shooter was calculated in a similar manner. 

```
    
### **Use of a Single Handgun**

'''{r}

handgun <-paste(as.character(round(100 *(sum(case_when(
      pull(shooting_data,`Firearm Type`) == "Handgun" ~ TRUE,
                                                 TRUE ~ FALSE), na.rm = TRUE)
    /
      sum(pull(shooting_data, `Firearm Type`)>=0, na.rm = TRUE)),
    1)), "%")

reporting_gun <- (sum(pull(shooting_data, `Firearm Type`)>=0, na.rm = TRUE)/
              length(pull(shooting_data, `Firearm Type`)))*100
reporting_gun <- round(reporting_gun, 1)


valueBox(value = handgun,
  color = "white")

'''

### **Shooter Was Male**
'''{r}


gender <- paste(as.character(round(100 * (sum(
    case_when(pull(shooting_data,`Shooter Gender`) == "Male" ~ TRUE,
                                                        TRUE ~ FALSE),
                                      na.rm = TRUE)
    /
      sum(pull(shooting_data, `Shooter Gender`)>=0, na.rm = TRUE)),
    1)), "%")

reporting_male <- (sum(pull(shooting_data, `Shooter Gender`)>=0, na.rm = TRUE)/
              length(pull(shooting_data, `Shooter Gender`)))*100
reporting_male <- round(reporting_male, 1)


valueBox(value = paste(gender),
  color = "white")
'''
```

Additional text about the reporting rate for these statistics was added using the `###` syntax. Additionally inline code is evaluated using the notation `"`r `"` Again notice that `"'"` was used instead of `"`"` just for illustrative purposes to allow this R Markdown document to render the code from the dashboard file.

```

###

reporting rate of shooter suicide = 'r reporting_suic'%,  
reporting rate of gun type = 'r reporting_gun'%,  
reporting rate of shooter gender = 'r reporting_male'%

```

</details> 

***

## The State Statistics Page (Interactive)

Let's create a page for **State Statistics** we would like to share. Importantly this page allows for the user to choose what state to look at.

### Look

This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "State_Statistics_page.png"))
```

### Overall Structure


Here is the overall structure for this page:

```{r, echo=FALSE, out.width="90%"}
knitr::include_graphics(here::here("img" , "states_stats_page_overview.png"))
```

**Note**: the other value Boxes are not included in this image. You can see that the `renderPlot()` function is used for plots and the `renderValueBox()` function is used for value boxes. 

### Details

On this page we want the user to be able to select data for a specific state and render plots and get statistics just for the selected state. To do this we will utilize the `renderPlot()` and `renderValueBox()` functions of the `flexdashboard` package, as well as the `selectInput()` function of the `shiny` package. See this [website](https://rmarkdown.rstudio.com/flexdashboard/shiny.html) for more information on using `shiny` to create interactive dashboards with `flexdashboard`.

***
<details> <summary> Click here to see the code for this page. </summary>

The first thing we need to do to allow this page to be interactive is to add `runtime: shiny` to the YAML header at the top of the R Markdown file.

The next thing we want to do is add the `{.sidebar}` attribute to the first column of this page. This allows us to use `shiny` input functions in this column.

Then, we use the `selectInput()` function to create a menu for the user to interact with and add it to this column.

Finally, we use the `renderPlot()` function  and `renderValueBox()` function to use the input from the user to render plots and value boxes based on their input.

The `selectInput()` function allows us to provide the user with a pull down menu of options for states. The main arguments for this function are:

1. `inputId` - this is what the selection will be called in subsequent code
2. `label` - this is what the user sees above the pull down menu
3. `choices` - this is a list of options for the menu
4. `selected` - this causes a particular option to be the default choice

This is placed in a column on the far left side that is more narrow than the others. 

```
State Statistics {data-icon=fa-flag-checkered}
===================================== 

Column {.sidebar data-width=250}
-----------------------------------------------------------------------

Note that the statistics shown do not account for other possibly influential state specific features like population density or gun laws among others.


'''{r}
  
selectInput(inputId = "state_selected", 
            label = "Select a state to explore:",
            choices = shooting_data %>% 
            pull(State) %>% 
            unique() %>%
            sort(), selected = "Alabama")

#  Washington, D.C. gets excluded by this
'''
```

Note that we used the `unique()` function to select only unique values of the `State` variable of the `shooting_data` tibble. The `sort()` function was used to put the options in alphabetical order.

In the next column, we have our plots like we did on the last page. Again we will use `tabset`. However, the difference here is that we need to include the `renderPlot()` function around all of our code for each plot and we need to use the data that the user selected. 

This will automatically be in a data object called `input` and it will be within a variable called `state_selected"` based on what we used for the `inputID` in the `select_Input()` function (this requires the base R way of selecting a specific variable using the `$`). 

Notice that the `renderPlot()` function requires that the code be within brackets `{}`. The data is filtered first for just the state that was selected. The code for the plots is essentially the same with minor modifications to allow for all unique cases that the different states present. For example the `deaths_perc_event %<>%filter (!duplicated(category))` is added to the last plot about the number of deaths per shooting to avoid duplication of the rows in cases like Colorado where the there is only one event that had 4 or more deaths (because in the other cases this value is a sum of all shooting with 4 or more deaths). 

It's always good to check as many possible input values as possible to make sure that your plot shows up as you expect!

```
Column {data-width=750 .tabset .tabset-fade}
-----------------------------------------------------------------------

### Yearly Deaths and Shootings

'''{r}
renderPlot({
shooting_data_state <- shooting_data %>% filter(State == input$state_selected)

shootings_per_year<- shooting_data_state  %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()

deaths_per_year<-shooting_data_state  %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))


per_year <- full_join(shootings_per_year, deaths_per_year)
per_year %<>% pivot_longer(cols = (-Date_year), 
                           values_to = "events", 
                           names_to = "id")

per_year %<>% 
  mutate(id = forcats::fct_inorder(id))

per_year %<>%
    ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_wrap(~id, scales = "free", 
               labeller = as_labeller(c(Shootings = "Shootings (# of events)", 
                                        Deaths = "Deaths (# of people)")), 
               strip.position = "left")+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
  scale_fill_manual(values = c("black", "black"))+
    labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = NULL,
         x = "Year") +
    theme_dashboard()+
    theme(title = element_text(size = 16, face = "bold"),
          axis.text = element_text(size = 14))
})
'''

### Yearly Cumulative Deaths and Shootings

'''{r}

renderPlot({

shooting_data_state <- shooting_data %>% filter(State == input$state_selected)

shootings_per_year<- shooting_data_state  %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()

shootings_per_year_cum <- 
  shootings_per_year %>%
  mutate(Shootings = cumsum(Shootings))

deaths_per_year<-shooting_data_state  %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))

deaths_per_year_cum <- 
  deaths_per_year %>%
  mutate(Deaths = cumsum(Deaths))

per_year_cum <- full_join(shootings_per_year_cum, deaths_per_year_cum)


per_year_cum %<>% 
  pivot_longer(cols = c(Shootings, Deaths ), 
               values_to = "events", 
                names_to = "id")
                
per_year_cum %<>% 
  mutate(id = forcats::fct_inorder(id))

per_year_cum %>%
ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_grid(~id)+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    scale_fill_manual(values = c("black", "black"))+
    theme_minimal() +
    labs(title = "Cumulative Yearly Shootings and Deaths\nAttributable to School Shootings",
         subtitle = input$state_selected,
         y = "Cumulative number of events",
         x = "Year") +
    theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background = element_rect(fill="cornflowerblue"),
        strip.text = element_text(colour = 'white', face = "bold", size = 14))

})

'''

### Deaths Per Shooting

'''{r}

renderPlot({

shooting_data_state <- shooting_data %>% filter(State == input$state_selected)
library(tidyr)
deaths_perc_event <-shooting_data_state %>%
   count(`Killed (includes shooter)`) %>%
   rename("num_events"= n) %>%
     tidyr::drop_na() %>%
   mutate(percent = round(num_events/sum(num_events)*100, digits =1))

greater_than4 <- 
  deaths_perc_event %>% 
  filter(`Killed (includes shooter)` >= 4) %>% 
  colSums()

deaths_perc_event %<>% bind_rows(greater_than4)

deaths_perc_event %<>% 
  mutate(category = paste0(`Killed (includes shooter)`, " deaths ", "\n(", percent, "%)")) 

deaths_perc_event %<>% 
  mutate(category = case_when(
    category ==  last(pull(deaths_perc_event, category)) ~ paste0("4+ deaths ", "\n(", percent, "%)"),
    category == "1 deaths" ~ "1 death",
    TRUE ~ category))

deaths_perc_event %<>% 
  filter (!duplicated(category))

deaths_perc_event %>% 
  select(-`Killed (includes shooter)`) %>%
  filter(str_detect(category, "0 deaths|1 death|2 deaths|3 deaths|4\\+")) %>%
  mutate(percent = round(percent)) %>%
  select(-num_events) %>%
  tidyr::pivot_wider(names_from = category, 
                    values_from = percent) %>%
  waffle::waffle(legend_pos = "bottom", title = "Deaths Per School Shooting", 
       xlab="1 square ~ 1%")+  scale_fill_viridis_d()

})

'''
```

In the third column, the state specific statistics are displayed. Some of these are static, while others update for the state selected. To calculate some of these we will also use data form the `poliscidata` function to get the state population values in 2010. The `pop2010_hun_thou` variable is the population in terms of 100,000 people.  avocado... this is the only thing I didn't really explain in detail... do you think we need to?

```
Column {data-width=450}
-----------------------------------------------------------------------

### **Total State Deaths**

'''{r}
renderValueBox({
shooting_data_state <- shooting_data %>% filter(State == input$state_selected)


valueBox(sum(pull(shooting_data_state,`Killed (includes shooter)`), na.rm = TRUE),
         color = "white")
})
'''

### **US State Average Death Count**

'''{r}
shooting_data_state <-shooting_data %>% 
  group_by(State_abb, State) %>%
  count(na.rm = TRUE) %>%
  rename(shootings = n) %>%
  ungroup() %>%
  mutate(state_sum = sum(shootings)) %>%
  mutate(state_avg = state_sum/50)

state_data <- poliscidata::states
state_data %<>%
  select(stateid, pop2010, pop2010_hun_thou) %>%
  mutate(stateid = as.character(stateid))%>%
  mutate(stateid = str_remove_all(stateid, pattern = " "))

shooting_data_state<-left_join(shooting_data_state, state_data, by = c("State_abb" = "stateid"))

deaths_State <-shooting_data %>% 
  group_by(State) %>%
  summarise( deaths = sum(`Killed (includes shooter)`, na.rm = TRUE))

state_data <- left_join(shooting_data_state, deaths_State)

USavg <- round(mean(pull(state_data, deaths), na.rm = TRUE), 2)
valueBox(USavg, color = "white")
'''


### **State Death Rate (per 100,000 people)**

'''{r}
state_data %<>%
  mutate(percapita_deaths  = deaths/pop2010_hun_thou)

renderValueBox({
  
  shooting_data_state <- state_data %>% filter(State == input$state_selected)

  valueBox(format(round(pull(shooting_data_state, percapita_deaths), digits = 3), nsmall = 3),
         color = "white")
})


'''

### **US National Death Rate (per 100,000 people)**

'''{r}
renderValueBox({

 US_percap <-summarize(state_data, sum(deaths, na.rm = TRUE))/ (summarize(state_data,sum(pop2010, na.rm = TRUE)) /100000)
 
valueBox(value = round(US_percap, digits = 3),
         color = "white")
})
'''

### **State Shooting Rate (per 100,000 people)**

'''{r}

state_data %<>%
  mutate(percapita_shootings  = shootings/pop2010_hun_thou)

renderValueBox({
  
  shooting_data_state <- state_data %>% filter(State == input$state_selected)

valueBox(format(round(pull(shooting_data_state, percapita_shootings), digits = 3), nsmall = 3),
         color = "white")
})


'''

### **US National Shooting Rate (per 100,000 people)**

'''{r}
renderValueBox({

 US_percap <-summarize(state_data, sum(shootings, na.rm = TRUE))/ (summarize(state_data,sum(pop2010, na.rm = TRUE)) /100000)
 
valueBox(value = round(US_percap, digits = 3),
         color = "white")
})
'''

###

Per capita calculations are based on 2010 population values.
```

</details>

***

##  The Map page (Interactive)

Next, we create our map page. Previously, in the  [**Data Exploration and Wrangling**] section, we geocoded our data and modified the `latitude` and `longitude` variables so that events that occurred in the same location would have slightly different values so that they will not cover one another in our map.

To create our map, we will use the `leaflet` package which uses the [Leaflet](https://leafletjs.com/)  JavaScript library. 

### Leaflet

`Leaflet` works by provided by adding base data (such as a map) and then adding markers if desired in layers. This is very similar to how `ggplot2` functions (pun intended).

The layers displayed can be controlled using a sort of legend. Depending on the type of layers, some information may be displayed mutually exclusive of the other layers; other layers (such as circles/general markers) can be toggled on and off. 

Clustering options can also be applied to circles/markers. Some examples of this can be found on the bottom of [this website](https://rstudio.github.io/leaflet/markers.html).

The `groups` in leaflet can be thought of as layer-specific IDs that create labels for legends and allow specific layers to be referred to in separate functions. 

Thus, if we called a group "Layer 1" and then in a subsequent layer refer to "Layer 1", `leaflet` will correctly identify which layer is being referenced.

Note that `leaflet` can require a lot of computational power depending on the types of maps produced.

### Look

This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "The_Map_Page.png"))
```

### Overall Structure

The overall structure for this page is simple. There is just one column ,which will contain the map.

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "map_page_structure.png"))
```

### Details

***
<details> <summary> Click here to see the code for this page. </summary>

First, we create a smaller dataset that just includes the data that we want to use in the map. We will include the date, the name of the school and the narrative for each point as a [popup](https://rstudio.github.io/leaflet/popups.html) that will be shown when the user hovers over a point. 

We need to do this using [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML) code as the `leaflet` package will ultimately render the map using this language.

We use the `paste()` function to combine these elements as well as HTML code to create line breaks and bold the name of the school.

To create line breaks in HTML, the `<br>` syntax is used. This is used to separate each part of the elements that are getting pasted together with the base `paste()` function by being specified as the separator with the `sep` argument.

To create bold font in HTML, the text is surrounded by `<b>` and `</b>` like so: `<b> Bold text </b>`. Thus only the school name is in bold.

Finally, the `<div>` and `</div>` are content dividers in HTML.  They separate the individual shooting event information sections that will be plotted on the map. The first divider can also take information about the style of the output. This uses [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) code, which is what is used to stylize HTML. 

The code here states that the height of the text box for each event should have a height that is proportional to the text, that the [height of each line](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height) should be of 1 [em units](https://www.w3.org/Style/Examples/007/units.en.html) (em stands for element). Hence, 1 unit relative to the size of the element. Therefore gaps between lines are the same height as the lines of text. The `overflow:visible` code specifies what to do in case the text box text is too large - in this case users can scroll (see [here](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow) for more options), and the [padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding) specification sets the size of the margins of the text box around the text.  

See this [website](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div) to learn more about HTML code.

```
Map {data-icon="fa-map"}
===================================== 
Column
------------------------------------- 
    
### 

This map shows where school shootings took place in the United States between January 1970 to June 2020 according to the the open-source [Center for Homeland Defense and Security](https://www.chds.us/c/) (CHDS) [K-12 School Shooting Database](https://www.chds.us/ssdb/dataset/). Click the circles for more information.

    
'''{r}
# specify the popups

shooting_information0 <- paste('<div style="height:auto;line-height:1em;overflow:scroll;padding:1em">',
                              shooting_data_geocoded$Date,
                              "<b>",
                              shooting_data_geocoded$School,
                              "</b>",
                              shooting_data_geocoded$`Narrative (Detailed Summary/ Background)`,
                              "</div>",
                              sep = "<br>")


'''
```

The next bit of code then uses this data and the `shooting_data_geocded` to actually create the map!

The `leaflet()` function of the `leaflet` package creates a Leaflet map [widget](https://en.wikipedia.org/wiki/Web_widget) using the  [`htmlwidgets`](https://cran.r-project.org/web/packages/htmlwidgets/index.html) package, which allows the map to be rendered as an application within HTML websites.

This first line of code starts the process of making the widget, but just like the `ggplot()` function of `ggplot2` it creates an empty map and layers need to be added.

The `addProviderTiles()` function of the `leaflet()` package does just that, by adding the map background. We will add three different kinds of map backgrounds. See [here](http://leaflet-extras.github.io/leaflet-providers/preview/index.html) for all the options of providers which create a variety of distinct backgrounds and then the `group` argument names each of these layers to be referred to later. The last layer added will be the one shown by default.

At this point we still only have a map in general. Now we need to add the data about shooting events. 

To do this, we add markers to the plot using the `addCircleMarkers()` function. This function takes many different arguments. See details about them [here](https://cran.r-project.org/web/packages/leaflet/leaflet.pdf). 

Importantly, we need to specify what variables in our provided data `shooting_data_geocoded` contains the longitude values (`lng`) and the latitude values (`lat`). 

We will also use the following arguments:  

- `radius` - argument specifies how large the circles for the points will be  
- `color` - argument specifies the color of the individual points  
- `fillOpacity` - argument allows for the filling of the points to a bit translucent if set below 1  
- `clusterOptions` - argument can be used to cluster points together into larger circles  
- `group` - argument specifies what the points should be called in the legend and what this layer should be referred to as for later use  

We also add a mini map using the `addMiniMap()` function, which can be useful to see where you are on the map. The type of plot style to use for the mini map is specified with the `tiles` argument and the `toggleDisplay` argument allows for the user to remove this feature.

Importantly, the `addLayersControl()` function  allows users to toggle between different backgrounds and markers. In our case we have three different background layers which are referred to as `baseGroups` and we have one `overlayGroups` which is our circle markers for shooting events. The group names for these need to be identified to allow users to toggle between them. 

The `set_view()` function allows for the starting position and zoom to be modified. This allows us to center the map around the continental US.

```
'''{r}
leaflet(shooting_data_geocoded) %>%
  addProviderTiles(provider = providers$OpenStreetMap, group = "OpenStreetMap") %>%
  addProviderTiles(provider = providers$Esri.WorldImagery, group = "ESRI World Imagery") %>%
  addProviderTiles(provider = providers$Stamen.TonerLite, group = "Toner")%>%
  addCircleMarkers(popup = ~shooting_information0,
                     lng = ~longitude,
                     lat = ~latitude,
     radius = 5,
     color = "red",
     fillOpacity = 0.2,
     clusterOptions = markerClusterOptions(),
     group = "Circles") %>%
  addMiniMap(tiles = providers$Stamen.Toner,
              toggleDisplay = TRUE) %>%
  addLayersControl(
     baseGroups = c("Toner Lite",
                    "OpenStreetMap",
                    "ESRI World Imagery"),
     overlayGroups = c("Circles")) %>%
   setView(lng = -98.35, lat = 39.5, zoom = 4)
'''
```

</details>
 
***
 

## The Tutorial Page

Here, we create a **Tutorial** page that links to this case study. This provides a simple overview of how we created the dashboard. 

### Look

This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "the_Tutorial_Page.png"))
```


### Overall Structure

To create this page we will use a special layout called a [storyboard](https://en.wikipedia.org/wiki/Storyboard). Story boards are used in many other fields, but the idea is that there are multiple images in a sequence. To create our storyboard page with `flexdashboard` we will use `{.stroyboard}` next to the page name. Each page name will be specified using this syntax: `###`. 

Here you see the top part of the overall structure:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "tutorialStructure.png"))
```

### Details

AVOCADO: all the following code and text in this section is in the back ticks. Should that be the case? It wasn't clear to me what should have been moved out? 

***
<details> <summary> Click here to see the code for this page. </summary>

```
Tutorial {.storyboard data-icon="fa-list-ol"}
=========================================   

### **1)** Load the `flexdashboard` package.

Install the package (and other supporting optional packages) if you don't have them installed already.

'''{r, echo=TRUE, eval=FALSE}
install.packages("flexdashboard")
install.packages("shiny")
install.packages("leaflet")
install.packages("ggplot2")
'''

Once installed, load the package(s) into the `R` environment.

'''{r, echo=TRUE}
library(flexdashboard)
library(shiny)
library(leaflet)
library(ggplot2)
'''

This all needs to be done separately in the `R` console.

### **2)** Create an `RMD` document.   

Dashboards can be created with `flexdashboard` in the `HTML` format. 

The`flexdashboard` package uses `RMarkdown` to produce dashboards that can contain `R` output.

This makes it possible to include several mediums in dashboards such as plots created with `ggplot2` or maps created with `leaflet`.
    
### **3)** Create an appropriate `YAML`.

The use of `flexdashboard` alters the way R Markdown documents function. 

R Markdown documents can be rendered into many different outputs, one of which is a dashboard. 
The `YAML` header sets up how the document output should be created.

Here is an example of a `YAML` header that creates an `HTML` document from an R Markdown document:


---
title: "Untitled"
author: "John Smith"
date: "8/12/2020"
output: html_document
---


We used the following `YAML` for this dashboard, which importantly includes `flexdahsboard::flex_dashboard`which specifies that a dashboard should be created and `runtime:shiny` which allows for the dashboard to be interactive:

output: 
  flexdashboard::flex_dashboard:
    logo: https://icons.iconarchive.com/icons/icons8/windows-8/48/Programming-Dashboard-icon.png
    theme: readable
    orientation: columns
    source_code: embed
    vertical_layout: fill
runtime: shiny


We also introduced an icon as a logo, provided a theme with a color scheme, defined the orientation (and thus order) of coded output, added a navigation bar item to give users easy access to the code used, and  limited scrolling with the `verticle_layout: fill` option.

### **4)** Design the layout of the dashboard.

Dashboards are inherently visual, making this step the most time intensive after content creation. To goal is to present the data in a way that is both meaningful and visually appealing.

On this dashboard, we wanted to present static plots of the United States and of individual states. We also wanted to display the locations of school shootings and provide some information about school shootings. Aside from being a dashboard, we wanted to create an educational resource that was reproducible for others. Lastly, as this is a sensitive topic, we wanted to raise awareness and provide information that could help others act.

Given these goals, we decided on the following page layout:

+ About
+ The Data
+ US Statistics
+ State Statistics
+ Map
+ Tutorial
+ Get Help

The first page gives users to the opportunity to look at the data themselves. More complicated components such as the map of each incident were left alone on a single page. US and state-level statistics were separated from one another. This short tutorial on how to create the dashboard and source code were included in the dashboard with programmers at all levels in mind.

### **5)** Add content to the dashboard.

You can begin adding content to the dashboard once you have an initial layout in mind. Keep in mind that this will likely be an iterative process. 

The R Markdown file used to create a dashboard with `flexdashboard` works similarly as it does in other cases, with a few exceptions.

R code chunks can be defined like so:


'''{r, echo = TRUE}
# Code chunks can be explicitly included
'''

'''{r, echo = FALSE}

# Code chunks are hidden by default 
'''

Pages and columns within pages can be defined like so:


Page
=========================================   

Column {data-width=500}
-------------------------------------

Column {data-width=500}
-------------------------------------


### **6)** Add content to the pages and columns.

Plots and other elements can be added within columns like so:

### Plot name

'''{r}
# include plot code here
'''

Value Boxes, which are essentially text boxes, can be defined like so:


### ValueBoxText

'''{r}
valueBox(value = 10
  color = "white")



Gauges, can be defined like so:

### GaugeText

'''{r}
flexdashboard::gauge(value = 10, 
                       min = 0, 
                       max = 100, 
                    symbol = "%")

'''

####
Which will produce output like this:
'''{r, out.width= "40%", echo = FALSE}
knitr::include_graphics(here::here("img", "gauge_output.png"))
'''

### Additional Info
As mentioned before, the `flexdashboard` metadata included in the `YAML` also alters how R Markdown documents are rendered. For more on how you can leverage both the `RMarkdown` package and the `flexdashboard` package to produce a dashboard, click [here](https://rmarkdown.rstudio.com/flexdashboard/index.html).

This [supplementary resource by the Open Case Studies project](INCLUDE LINK HERE) provides a case study on how to create this very dashboard in more detail.

```

</details>

***

## The Get Help page

We create a **Get Help** page to spread awareness on this important public health topic.

### Look

This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "The_Get_Help_Page.png"))
```


### Overall Structure

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "The_Get_Help_Page_structure.png"))
```


### Details

AVOCADO: should there be more text in this section explaining things?

***
<details> <summary> Click here to see the code for this page. </summary>

```
Get Help {data-icon="fa-exclamation-triangle"}
=========================================   

Column {data-width=800}
-------------------------------------

###

**Warning Signs**

From [Sandy Hook Promise](https://www.sandyhookpromise.org/gun-violence/know-the-signs-of-gun-violence/)...

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Here is a list of potential warning signs that can signal an individual may be in crisis and/or need help:

+ Suddenly withdrawing from people and activities
+ Consistent bullying or intimidating others, or being bullied by others
+ Extreme mood or personality changes
+ Victim of constant social rejection
+ Talking about plans or actively making plans to harm themselves or others
+ Bringing a weapon to school – or threatening or talking about doing so
+ Bragging about or warning others about an upcoming act of violence
+ Recruiting others to join in a planned act of violence
+ Warning students to stay away from school or events
+ Expressing fascination with guns and/or school shootings
+ Expressing hopelessness about the future
+ Extreme, prolonged sadness or distress
+ Expressing or showing feelings of isolation
+ Bragging about access to guns

**This list is not a comprehensive list of warning signs nor does exhibiting one of these signs indicate imminent violence.**

According to the following article:

Flannery, D. J., Modzeleski, W. & Kretschmar, J. M. Violence and School Shootings. Curr Psychiatry Rep 15, 331 (2013). DOI: [10.1007/s11920-012-0331-6](https://doi.org/10.1007/s11920-012-0331-6)

"To date, studies of school shootings have concluded that no
consistent and reliable profile of school shooters exist, and
most researchers and clinicians would agree that predicting
violent behavior is a slippery slope that will usually result in
more false positives than false negatives."

"...most shooters were depressed, had experienced some significant
loss, felt persecuted or bullied by others, and had prior
difficulty coping or had previously tried suicide. Most of
the shooters did not, however, have a history of drug abuse
or violence or cruelty to animals, common psychiatric indicators of risk, nor did they report excessive exposure to
violence in the media (though many produced their own
violent themes in writings or drawings)."

</div>


<style>
div.red { background-color:#BC8F8F; border-radius: 5px; padding: 20px;}
</style>
<div class = "red">

According to the [National Institute of Mental Health (NIMH)](https://www.nimh.nih.gov/health/publications/teen-depression/index.shtml){target="_blank"}:

For youths who may be at risk for suicidal behavior, visit the **National Suicide Prevention Lifeline (NSPL)** website at [www.suicidepreventionlifeline.org](www.suicidepreventionlifeline.org){target="_blank"}.

Additionally, the **Crisis Text Line** is another free, confidential resource available 24 hours a day, seven days a week. Visit [www.crisistextline.org](www.crisistextline.org){target="_blank"} for more information.

Also see [here](https://www.mhanational.org/depression-teens-0){target="_blank"} for more information about how to recognize and help youths experiencing symptoms of depression and warning signs of suicide.

</div>


Column {data-width=200}
-------------------------------------

### 

**Respond to Warning Signs**

When concerned about troubling behaviors, tell a trusted adult.


Call **911** if you feel there is an immediate threat. 

Call [+1-844-5-SAYNOW](tel:18445729669) if you would like to submit an anonymous safety concern.

Text “HOME” to **741741** to text a trained crisis counselor 24 hours a day.

The **National Suicide Prevention Lifeline (NSPL)** is available 24 hours a day, every day at **[1-800-273-TALK (8255)](tel:18002738255)**. 

The deaf and hard of hearing can contact the **(NSPL)** via TTY at **[1-800-799-4889](tel:18007994889)**. All calls are confidential.
```

</details>

***

# **Summary**
*** 

## Synopsis

In this case study, we demonstrated the basics of R Markdown and how to create a dashboard with using the `flexdashboard` package. We also demonstrated how to include an interactive table with the `DT` package, how to include interactive plots using functions of the `shiny` package such as `renderPlot()`. We included interactive value boxes using the `renderValueBox()` function of the `flexdashboard` package, which works with the `shiny` package. Finally, we showed how to include interactive maps using the `leaflet` package. 

This case study also explored how to properly calculate and interpret percentages when the data has missing values. We also discussed the benefits and limiting aspects of pie charts (using the `ggplot2` package) and waffle plots (using the `waffle` package).

Overall, the dashboard we created shows that the number of shootings per year has increased overtime. Further investigation is necessary to determine if this is simply due to increases in population alone or if the rate has increased due to other factors and if so, what those factors might be. It is also clear that the number of shootings and the number of deaths per capita varies by state. There appears to be other aspects accounting for state differences. 

# **Suggested Homework**
*** 

Create another dashboard with graphs and statistics featuring other elements within this dataset. For example, students may create graphs that explore what school events are reported to have more shootings.


# **Additional Information**
***

## Helpful Links

[RStudio](https://rstudio.com/products/rstudio/features/){target="_blank"}  
[Cheatsheet on RStuido IDE](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf){target="_blank"}  
[Other RStudio cheatsheets](https://rstudio.com/resources/cheatsheets/){target="_blank"}   
[RStudio projects](https://r4ds.had.co.nz/workflow-projects.html)

[Tidyverse](https://www.tidyverse.org/){target="_blank"}   

[Piping in R](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html){target="_blank"}   

[String manipulation cheatsheet](https://rstudio.com/resources/cheatsheets/){target="_blank"}  
[Table formats](https://en.wikipedia.org/wiki/Wide_and_narrow_data){target="_blank"}

[Geocoding](https://en.wikipedia.org/wiki/Geocoding)  
[Coordinate reference system (CRS)](https://www.w3.org/2015/spatial/wiki/Coordinate_Reference_Systems) [ESPG](https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset)
[World Geodetic System (WGS) version 84 also called ESPG:4326 ](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84)   
[Albers equal-area conic projection](https://en.wikipedia.org/wiki/Albers_projection#:~:text=The%20Albers%20equal%2Darea%20conic,that%20uses%20two%20standard%20parallels.&text=The%20Albers%20projection%20is%20used,the%20United%20States%20Census%20Bureau.)   
[crs 102008](https://spatialreference.org/ref/esri/102008/html/)  

To learn more about geospatial coordinate systems see [here](https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf) and [here](https://guides.library.duke.edu/r-geospatial/CRS).


[`ggplot2` package](http://ggplot2.tidyverse.org){target="_blank"}    
Please see [this case study](https://opencasestudies.github.io/ocs-bp-co2-emissions/)  for more details on using `ggplot2`    
[grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html){target="_blank"}   
[`ggplot2` themes](https://ggplot2.tidyverse.org/reference/ggtheme.html){target="_blank"}   

[Motivating article for this case study about school shootings](https://link.springer.com/content/pdf/10.1007/s11920-012-0331-6.pdf)

Also see this [article](https://siepr.stanford.edu/sites/default/files/publications/19-036.pdf) to learn more about the impacts of school shootings.


[Lightweight markup languages(LML)](https://en.wikipedia.org/wiki/Lightweight_markup_language)  
[Markdown](https://en.wikipedia.org/wiki/Markdown)  
[R Markdown](http://rmarkdown.rstudio.com/)   
[`knitr`](https://yihui.org/knitr/)  
[`rmarkdown` (package)](https://cran.r-project.org/web/packages/rmarkdown/rmarkdown.pdf)

See this [book](https://bookdown.org/yihui/rmarkdown/) for more information on working with R Markdown files. 

The RStudio [cheatsheet for R Markdown](https://github.com/rstudio/cheatsheets/raw/master/rmarkdown-2.0.pdf) and this [tutorial](https://ourcodingclub.github.io/tutorials/rmarkdown/) are great for getting started. 

[Pandoc](https://en.wikipedia.org/wiki/Pandoc)  

[YAML](https://en.wikipedia.org/wiki/YAML)  
[Configuration](https://en.wikipedia.org/wiki/Configuration_file)  

[flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/)  

See [here](https://rstudio.com/resources/webinars/introducing-flexdashboards/) for a video about flexdashboard and [here](https://rmarkdown.rstudio.com/flexdashboard/) for a more information on how to use this package.   
See [here](https://rmarkdown.rstudio.com/flexdashboard/using.html#components) for a list of other packages that are useful for adding elements to dashboards created with the `flexdashboard` package.   
See [here](https://www.datadreaming.org/post/r-markdown-theme-gallery/) for a list of R Markdown themes which can be used with `flexdashbard`.   
See [Font Awesome](https://fontawesome.com/icons?d=gallery) for icons.  

To learn more about using `shiny` with the `flexdashboard` package to create interactive dashboards, see this [tutorial](https://rmarkdown.rstudio.com/flexdashboard/shiny.html).   

[leaflet (R package)](https://rstudio.github.io/leaflet/)   
[Leaflet (JavaScript Library)](https://leafletjs.com/)   

[shiny](https://shiny.rstudio.com/)  
See [here](https://shiny.rstudio.com/gallery/) for a gallery of `shiny` examples.

See this [website](https://rstudio.github.io/shinydashboard/) to learn about a more flexible and slightly more challenging option for creating dashboards in R using a package called `shinydashboard`.


<u>**Packages used in this case study:** </u>

Package   | Use in this case study                                                                      
---------- |-------------
[here](https://github.com/jennybc/here_here){target="_blank"}       | to easily load and save data  
[readr](https://readr.tidyverse.org/) |  to import the data  as a csv file  
[googlesheets4](https://googlesheets4.tidyverse.org/) | to import directly from Google Sheets
[tibble](https://tibble.tidyverse.org/) | to create tibbles (the tidyverse version of dataframes)
[dplyr](https://dplyr.tidyverse.org/){target="_blank"}      | to filter, subset, join, add rows to, and modify the data  
[stringr](https://stringr.tidyverse.org/){target="_blank"}      | to manipulate  character strings within the data (collapsing strings together, replace values, and detect values)
[magrittr](https://magrittr.tidyverse.org/){target="_blank"}      | to pipe sequential commands 
[tidyr](https://tidyr.tidyverse.org/){target="_blank"}      | to change the shape or format of tibbles to wide and long, to drop rows with `NA` values, and to see the last few columns of a tibble
[ggmap](https://cran.r-project.org/web/packages/ggmap/ggmap.pdf) | to geocode the data (which means get the latitude and longitude values)
[sf](https://r-spatial.github.io/sf/) | to modify the geocoded data so that overlapping points did not overlap
[lubridate](https://lubridate.tidyverse.org/) | to work with the data-time data    
[DT](https://rstudio.github.io/DT/) | to create the interactive table  
[htmltools](https://www.rdocumentation.org/packages/htmltools/versions/0.5.0) | to add a caption to our interactive table 
[ggplot2](https://ggplot2.tidyverse.org/){target="_blank"}      | to create plots  
[ggforce](https://cran.r-project.org/web/packages/ggforce/ggforce.pdf)   | to create a plot zoom
[forcats](https://forcats.tidyverse.org/){target="_blank"}      | to reorder factor for plot
[waffle](https://github.com/hrbrmstr/waffle) | to make waffle proportion plots  
[poliscidata](https://cran.r-project.org/web/packages/poliscidata/poliscidata.pdf) | to get population values for the states
[flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/)     | to create the dashboard  
[shiny](https://shiny.rstudio.com/){target="_blank"}      | to allow our dashboard to be interactive   
[leaflet](https://rstudio.github.io/leaflet/shiny.html) | to implement the [leaflet](http://leafletjs.com/) (a JavaScript library for maps) to create the map for our dashboard   
[maps]() | AVOCADO: needs to be added. Rmd did not compile otherwise. 
[vembedr]() | AVOCADO: needs to be added. Rmd did not compile otherwise. 


#### {.emphasis_block}

**Warning Signs**

From [Sandy Hook Promise](https://www.sandyhookpromise.org/gun-violence/know-the-signs-of-gun-violence/)...

Here is a list of potential warning signs that can signal an individual may be in crisis and/or need help:

+ Suddenly withdrawing from people and activities
+ Consistent bullying or intimidating others, or being bullied by others
+ Extreme mood or personality changes
+ Victim of constant social rejection
+ Talking about plans or actively making plans to harm themselves or others
+ Bringing a weapon to school – or threatening or talking about doing so
+ Bragging about or warning others about an upcoming act of violence
+ Recruiting others to join in a planned act of violence
+ Warning students to stay away from school or events
+ Expressing fascination with guns and/or school shootings
+ Expressing hopelessness about the future
+ Extreme, prolonged sadness or distress
+ Expressing or showing feelings of isolation
+ Bragging about access to guns

**NOTE**

This list is not a comprehensive list of warning signs nor does exhibiting one of these signs indicate imminent violence.

When concerned about seeing troubling behaviors, tell a trusted adult or call 911, if there is an immediate threat.

**Respond to Warning Signs**

Call 911 if you feel there is an immediate threat. 

Call [+1-844-5-SAYNOW](tel:18445729669) if you would to submit an anonymous safety concern.


If you or your child or student experienced a shooting please see this [website](https://kidshealth.org/en/parents/ptsd.html) and this [website](https://www.verywellmind.com/shooting-ptsd-from-a-shooting-2797200) for guidance about dealing with the trauma.


####

## Session Info

```{r}
sessionInfo()
```


## Acknowledgements

We would like to acknowledge [Elizabeth Stuart](https://www.jhsph.edu/faculty/directory/profile/1792/elizabeth-a-stuart) for assisting in framing the major direction of the case study.

We would also like to acknowledge the [Bloomberg American Health Initiative](https://americanhealth.jhu.edu/) for funding this work. 

