---
title: "Fifty Years of School Shootings in the United States"
css: style.css
output:
  html_document:
    self_contained: yes
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes

---

<style>
#TOC {
  background: url("https://opencasestudies.github.io/img/logo.jpg");
  background-size: contain;
  padding-top: 240px !important;
  background-repeat: no-repeat;
}
</style>


<!-- Open all links in new tab-->  
<base target="_blank"/> 

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE, cache = FALSE,
                      fig.align = "center", out.width = '90%')
library(here)
library(knitr)
```

#### {.outline }
```{r, echo=FALSE}
knitr::include_graphics(here("screenshots",
                             "final_plot.png"))
```
####

#### {.disclaimer_block}

**Disclaimer**: The purpose of the [Open Case Studies](https://opencasestudies.github.io){target="_blank"} project is **to demonstrate the use of various data science methods, tools, and software in the context of messy, real-world data**. A given case study does not cover all aspects of the research process, is not claiming to be the most appropriate way to analyze a given data set, and should not be used in the context of making policy decisions without external consultation from scientific experts. 

####

#### {.license_block}

This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 [(CC BY-NC 3.0)](https://creativecommons.org/licenses/by-nc/3.0/us/){target="_blank"} United States License.

####

#### {.reference_block}

To cite this case study please use:

Wright, Carrie, and Ontiveros, Michael and Jager, Leah and Taub, Margaret and Hicks, Stephanie. (2020). https://github.com/opencasestudies/ocs-youth-school-shootings-dashboard-case-study. Fifty Years of School Shootings in the United States (Version v1.0.0).

####

# **Motivation**
*** 

This case study is motivated by this [article](https://link.springer.com/content/pdf/10.1007/s11920-012-0331-6.pdf):

#### {.reference_block}

Flannery, D. J., Modzeleski, W. & Kretschmar, J. M. Violence and School Shootings. Curr Psychiatry Rep 15, 331 (2013). DOI: [10.1007/s11920-012-0331-6](https://doi.org/10.1007/s11920-012-0331-6)

####

This article explores characteristics of school shootings and violence in schools and discusses why these events may occur, as well as their impact on the communities in which they occur.



This article states that the shooters of most commonly white males, but that many previous studies of shooter characterisitcs could not identify any particular "profile" of shooters.

> "To date, studies of school shootings have concluded that no
consistent and reliable profile of school shooters exist, and
most researchers and clinicians would agree that predicting
violent behavior is a slippery slope that will usually result in
more false positives than false negatives."

However previous studies note some commonalites such as:

> "...most shooters were depressed, had experienced some significant
loss, felt persecuted or bullied by others, and had prior
difficulty coping or had previously tried suicide. Most of
the shooters did not, however, have a history of drug abuse
or violence or cruelty to animals, common psychiatric indicators of risk, nor did they report excessive exposure to
violence in the media (though many produced their own
violent themes in writings or drawings)."


```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "joshua-hoehne-CAokgx1GGKE-unsplash.jpg"))
```


<span>Photo by <a href="https://unsplash.com/@mrthetrain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Joshua Hoehne</a> on <a href="https://unsplash.com/s/photos/high-school?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>



> "School shootings are not all the same and may require
different approaches to prevention and treatment, especially
with respect to identifying risk factors at the individual, school
or community levels, and particularly with regard to examining
the role that mental health issues may play to increase risk for
perpetration. The field **needs to know more** about shooting
incidents that are averted, those that result in injury but not
death and about the characteristics of the more common occurrence of single homicide school shootings."


```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "andre-hunter-AQ908FfdAMw-unsplash.jpg"))
```

<span>Photo by <a href="https://unsplash.com/@dre0316?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Andre Hunter</a> on <a href="https://unsplash.com/s/photos/high-school?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>


They also point out that:

> "Most media attention is on the mental health of school shooters, but we cannot forget the **impact of school shooting incidents on the surviving victims**, including those who may not have been injured but who may have witnessed the incident or been affected by it in other ways. Psychiatrists must pay attention to the long-term mental health consequences of these incidents on all affected parties (not just formal PTSD diagnoses, but related trauma symptoms) as well as maladaptive coping strategies that some may employ in response to such unpredictable, tragic events."

Given this need for more research to better understand why these events occur and how they could be averted, in this case study we will demonstrate how to create a resource for others to more easily and interactively access data about school shootings. To do so we will create what is called a [dashboard](https://en.wikipedia.org/wiki/Dashboard_(business)), which is a website that displays a report for a database. Dashboards summarize the data in a database and typically allow for users to interact with the data in some way.

[Here](https://beta.rstudioconnect.com/jjallaire/htmlwidgets-highcharter/htmlwidgets-highcharter.html) you can see an example of a dashboard created in R.


On the website the tabs and and plots are interactive. The dashboard allows for users to get to know the data in a simple and quick way.

The data about food sales  is succinctly summarized in an impactful manner.

```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "dashboard.png"))
```

####[[source]](https://beta.rstudioconnect.com/jjallaire/htmlwidgets-highcharter/)

Now let's learn how to do this with our data of interest.

# **Main Questions**
*** 

#### {.main_question_block}
<b><u> Our main questions: </u></b>

1) What has been the yearly rate of school shootings and where have they occurred in the last 50 years (from January 1970 to June 2020)? 

2) What are the characteristics of these events?

####

# **Learning Objectives** 
*** 

In this case study, we will demonstrate how to create a [dashboard](https://en.wikipedia.org/wiki/Dashboard_(business)), which is a website that displays a report about a database. We will especially focus on using packages and functions from the [`Tidyverse`](https://www.tidyverse.org/){target="_blank"}, such as `package_name`, `package_name`. The tidyverse is a library of packages created by RStudio. While some students may be familiar with previous R programming packages, these packages make data science in R more legible and intuitive.


```{r, out.width = "20%", echo = FALSE, fig.align ="center"}
include_graphics("https://tidyverse.tidyverse.org/logo.png")
```

The skills, methods, and concepts that students will be familiar with by the end of this case study are:

Avocado update here and in readme!

Data science skills:  
  
1. Importing text from a google sheets document (`googlesheets4`)  
2. Converting date formats (`lubridate`)  
3. Geocoding data (`ggmap`)  
4. How to reshape data by pivoting between "long" and "wide" formats and separating columns into additional columns (`tidyr`)  
5. How to create data visualizations with `ggplot2` 
6. An introctory understand of R Markdown  
7. How to create an interactive table (`DT`)  
8. How to create a map (`leaflet`)  
9. How to create an interactive dashboard with `flexdashboard` and `shiny`  


Statistical concepts and methods:  
  
1. Calculating percentages with missing values  

https://www.reddit.com/r/rstats/comments/9gipi1/html_within_span_created_by_flexdashboardfunction/e64l2up/
avocado add shinydashboard info
*** 


We will begin by loading the packages that we will need:


```{r}
library(here)
library(readr)
library(dplyr)
library(tidyr)
library(magrittr)
library(ggmap)
library(sf)
library(ggplot2)
library(forcats)
library(waffle)
library(flexdashboard)
library(shiny)
library(tidyverse)
library(leaflet)

library(rmapshaper)
library(htmltools)
library(lubridate)
library(DT)
```


 <u>**Packages used in this case study:** </u>

Package   | Use in this case study                                                                      
---------- |-------------
[here](https://github.com/jennybc/here_here){target="_blank"}       | to easily load and save data  
[readr](https://readr.tidyverse.org/) |  to import the data    
[dplyr](https://dplyr.tidyverse.org/){target="_blank"}      | to filter, subset, join, add rows to, and modify the data    
[stringr](https://stringr.tidyverse.org/){target="_blank"}      | to manipulate  character strings within the data
[magrittr](https://magrittr.tidyverse.org/){target="_blank"}      | to pipe sequential commands 
[ggmap](https://cran.r-project.org/web/packages/ggmap/ggmap.pdf) | to geocode the data (which means get the latitude and longitude values for the schools)
[waffle](https://github.com/hrbrmstr/waffle) | to make waffle proportion plot
[flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/)     | to create the elements of the dashboard 

[tidyr](https://tidyr.tidyverse.org/){target="_blank"}      | to change the shape or format of tibbles to wide and long, to drop rows with `NA` values, to separate a column into additional columns, and to fill out values based on previous values   
[shiny](https://shiny.rstudio.com/){target="_blank"}      | to allow our dashboard to be interactive  
[leaflet](https://rstudio.github.io/leaflet/shiny.html) | to implement the [leaflet](http://leafletjs.com/) (a JavaScript library for maps) to create the map for our dashboard   
[sf](https://r-spatial.github.io/sf/) | to Geocode the data avocado
[rmapshapper](https://cran.r-project.org/web/packages/rmapshaper/vignettes/rmapshaper.html) | avocado
[htmltools](https://www.rdocumentation.org/packages/htmltools/versions/0.5.0) | to avocado   
[lubridate](https://lubridate.tidyverse.org/) | to work with the data-time data    
[DT](https://rstudio.github.io/DT/) | to create the interactive table  
[ggplot2](https://ggplot2.tidyverse.org/){target="_blank"}      | to create plots  
[directlabels](http://directlabels.r-forge.r-project.org/docs/index.html){target="_blank"}      | to add labels directly to lines in plots  
[cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html){target="_blank"}      | to add images to plots 
[forcats](https://forcats.tidyverse.org/){target="_blank"}      | to reorder factor for plot

[patchwork](https://github.com/thomasp85/patchwork) | to combine plots



The first time we use a function, we will use the `::` to indicate which package we are using. Unless we have overlapping function names, this is not necessary, but we will include it here to be informative about where the functions we will use come from.


# **Context**
*** 

Although school shooting events that result in homicide are rare, they can have a lasting impact on the communities in which they occur. Furthermore, suicide events and shootings with no victims can also be impactful.

According to the [Center for Injury Research and Prevention at the Children's Hospital of Philadelphia](https://injury.research.chop.edu/violence-prevention-initiative/types-violence-involving-youth/school-shootings):

>The most common shootings on school grounds rarely involve large numbers of victims, but even a shooting of just one student at school has ramifications far beyond those directly involved. Students and staff that witness school shootings are likely to suffer from [traumatic stress](https://en.wikipedia.org/wiki/Traumatic_stress) symptoms, become anxious or depressed and have general concerns about their safety. While many witnesses will have temporary symptoms, others will be symptomatic for a much longer period of time and even develop chronic psychiatric disorders. Even short-term impairments can cause severe distress and have profound effects on academic achievement and the social and emotional growth of impacted students. 
 
Furthermore, fatal shootings can have vast and lasting impacts because many students can witness a single event.

Another recently published [article](https://siepr.stanford.edu/sites/default/files/publications/19-036.pdf) indicates that:

> Over **240,000** American students experienced a school shooting in the last two decades.


```{r}
knitr::include_graphics(here::here("img", "exposed.png"))

```

##### [[source]](https://siepr.stanford.edu/sites/default/files/publications/19-036.pdf)
 
This study followed students who experienced a school shootting the United States between 2008 and 2013 and assessed their mental well-being. They found that:

> Fatal school shootings have large and persistent impacts on the mental health of local youth. In the two years following a fatal school shooting, the monthly number of antidepressant prescriptions written to individuals under age 20 is 21.3 percent higher in the shooting-exposed relative to the reference areas. 

```{r, echo = FALSE, outwidth = "40%"}
knitr::include_graphics(here::here("img", "fernando-cferdo-6x2iKGi6SPU-unsplash.jpg"))
```

<span>Photo by <a href="https://unsplash.com/@cferdo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Fernando @cferdo</a> on <a href="https://unsplash.com/s/photos/depression?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>


#### {.reference_block}

Rossin-Slater, M., Schnell, M., Schwandt, H., Trejo, S. & Uniat, L. Local Exposure to School Shootings and Youth Antidepressant Use. w26563 http://www.nber.org/papers/w26563.pdf (2019) doi:10.3386/w26563.

####
 
# **Limitations**
*** 
There are some important considerations regarding this data analysis to keep in mind: 

1) This analysis is exploratory and, as such, does not intend to provide inferential conlcusions.  

2) This dashboard only uses one source of data. There may be school shooting events that are not listed in this data or errors in this data.

According to the database website:

>"This database was developed from open-source information and may include reporting errors."

Furthermore, according to this [article](https://link.springer.com/article/10.1007/s11920-012-0331-6) schools are not required to report school shootings unless they resulted in a suicide or homicide, therefore there may be more events that result in only injury or no injuries or death that may not be included.

There are indeed events in the dataset that include zero deaths and zero injuries, but it is very likely that many of these events are not listed.

Avocado... this source from 2013 says that schools are not required to report.. is this still true?


# **What are the data?**
*** 

We will use data from the open-source [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) downloaded from the [Center for Homeland Defense and Security](https://www.chds.us/c/) at the at the [Naval Postgraduate School(NPS)](https://en.wikipedia.org/wiki/Naval_Postgraduate_School) in Monterey, California. This data is updated daily. The data used in this case study was downloaded in June of 2020. 

#### {.reference_block}

Riedman, David, and Desmond O’Neill. “CHDS – K-12 School Shooting Database.” Center for Homeland Defense and Security, June 2020, [www.chds.us/ssdb](www.chds.us/ssdb).

####

This database includes information about school shooting events for students in grades K-12 in the United States dating back to 1970. The database has additional information not shown on our dashboard including but not limited to: 


* Location of the event at the school  
* If the event occured during a sporting event  
* Time of day of the event  
* Day of the week of the event  
* Source for the shooting information  
* If the event was pre-planned or not  
* Shooter's actions immediately following the shooting  
* Shooter characteristics (affiliation with the school, if they had accomplices, if they took hostages, and their age and race)  
* Victom characteristics (afficliation with the school, if they were targeted, their age and race)  

According to the [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) website:

> The School Shooting Database Project is conducted as part of the [Advanced Thinking in Homeland Security (HSx)](https://www.chds.us/c/academic-programs/hsx/) program at the Naval Postgraduate School’s [Center for Homeland Defense and Security (CHDS)](Center for Homeland Defense and Security (CHDS).

> The database compiles information from more than 25 different sources including peer-reviewed studies, government reports, mainstream media, non-profits, private websites, blogs, and crowd-sourced lists that have been analyzed, filtered, deconflicted, and cross-referenced. All of the information is based on open-source information and 3rd party reporting.

# **Data Import**
*** 
Since we downlaoded the csv file from the [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) website we can import this raw data file using  the `read_csv()` function of the `readr` package. 

We will use the `here()` function of the `here` package to easily locate the data within the `raw_data` directory within the directory that contains the .Rproj file.

We want to skip the first row that states:
Updated 6/2/2020 - View graphs and research methodology on www.chds.us/ssdb If you have information about other incidents, please email K12ssdb@chds.us."

To do this, we can use the `skip` argument of this function and specify that we wish to only skip 1 row with `skip = 1`. We can also specify that the next row should be used for column names using the `col_names = TRUE` argument. 


```{r}

shooting_data <- readr::read_csv(file = here::here("raw_data", "K-12_SSDB_(Public)-K-12_SSDB_(Public)_Linked.csv"), col_names = TRUE, skip = 1)
```


We can use the `glimpse` function of the `dplyr` package to take a look at columns within the database:

#### {.scrollable }
```{r}
# Scroll through the output!
glimpse(shooting_data)
```

####

We can also use the utils `str()` function to see more detials about the values. Typically we would be able to see these with `glimpse()` but some of the columns have very long names, thus obscuring the first few values in the output.

#### {.scrollable }
```{r}
# Scroll through the output!
str(shooting_data)
```

####

Alternatively, if we wanted to make a dashboard that continuely updated as the data got updated, we could do the following to import the data directly from the googlesheets document.

To do so we would use the `read_sheet()` function of the `googlesheets4` package. Typically authentication is required, which is genearlly simple, but since this is a public sheet we don't need to worry about authentication. To avoid this we would need to use the `gs4_deauth()` function which puts the package into a de-authorized state. 



```{r}
googlesheets4::gs4_deauth()
```

Great, now we would need to get the shared link from the document. We can do so by clicking on the link to the actually google sheets document like so:
```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "gettodoc.png"))
```

Then we can click on the "share" button to get access to the link:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "gettoshare.png"))
```

Finally we can click on "copy link" button to copy the link:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "getlink.png"))
```

Once you have copied the link, you can use the `read_sheet()` function to import the data by simply pasting the link within the parantheses of the function in quotes, like so:

```{r eval = FALSE}

googlesheet_data <- read_sheet("https://docs.google.com/spreadsheets/d/1HqbfMxnk9X3_mQvLyW_LEUe3Yyr7cXMPfwqUVfdq7sY/edit?usp=sharing")

```

This is a great option, however, we chose not to do this for this case study to allow this tutorial to be more easily maintained over time.

####

# **Data Exploration and Wrangling**
***
Luckily, our data is already in pretty good shape, but we want to make our data more useful for our dashboard. 

## Adding state name

It would be useful to have the full state name in our data, rather than just the abbreviation.

We can do so by using data related to the US 50 states in a dataset called `state` that is automatically loaded with R sessions in the `datasets` package. The `state.abb` object is a list of the state abbreviations and `state.name` is a list of the state names.

```{r}
state.abb
state.name
```

We will combine these using the `tibble()` function of the `tibble()` package. 

```{r}
state_df <- tibble(State_abb = state.abb, State = state.name)

slice_head(state_df, n= 4)
```

Now we will combine this with our data using the `left_join()` function of the `dplyr` package.
There are several ways to join data using the `dplyr` package.


```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "join.png"))
```

##### [[source]](https://dplyr.tidyverse.org/reference/join.html)

Here is  a visualization of these options:

```{r, echo = FALSE, outwidth = "50%"}
knitr::include_graphics(here::here("img", "join_image.png"))
```

##### [[source]](https://rstudio.com/resources/cheatsheets/)

See [here](https://dplyr.tidyverse.org/reference/join.html) for more detials about joining data.

We probably have data for all fifty states, but there may not have been shootings in all 50 states in this dataset, therefore we dont want to use the `full_join()` function. We also don't want the `inner_join()` function because `DC` does not have a state name. Thus we will use the `left_join()` function where x in this case will be the `shooting_data` (as it is introduced to this code first through the `%<>` pipe opperator) and y is the `state_df`. Thus we add the `state_df` values where they match to the `shooting_data`.

```{r}
shooting_data %<>%
  rename("State_abb" = State) %>%
  left_join(state_df, by = c("State_abb" = "State_abb"))
```

```{r}
shooting_data %>%
  select(School, City, State_abb, State) %>%
  slice_head(n = 4)
```

## Reformating dates
We also want to reformat our date values and create a `Date_year` variable based on the year in each date. We can use the `lubridate` package for this.

The `mdy()` function converts dates into a format where dates are listed as month, date, and year with hyphens in between.
The `year()` function can then be used to extract just the year from each date.

```{r}
shooting_data %<>%
       mutate(Date = lubridate::mdy(Date)) %>%
  mutate(Date_year = lubridate::year(Date))

shooting_data %>% select(Date, Date_year)
```
Looks good!

One last thing to do is to convert `Yes` and `No` values into `TRUE` and `FALSE`.


First let's take a look at our data:

#### {.scrollable }
```{r}
str(shooting_data)

```

####

We see that many of the varaibles have either `Yes` or `No` values or `Y` and `N` values.  These are the variables that have `Y/N` in the name or the `Targeted Specific Victim(s)`, `Random Victims`, `Pre-planned school attack` variables. We can make these consistently `TRUE` and `FALSE` by using the `case_when()` function of the `dplyr` package. This function allows us to specify new values for existing values, simlarly to the `recode()` function also of `dplyr`. The benefit of the `case_when()` function, is that changing the values to `TRUE` or `FALSE` also results in the class type of the variable changing to type logical (which is interpreted as a binary variable with `TRUE` and `FALSE` values) otherwise, with `recode()` the variables would remain as class type character. 

<details> <summary> Click here for an explanation about data types in R. </summary>

There are several classes of data in R programming. 
Character is one of these classes. 
A character string is an individual data value made up of characters. 
This can be a paragraph, like the legend for the table, or it can be a single letter or number like the letter `"a"` or the number `"3"`. 
If data are of class character, than the numeric values will not be processed like a numeric value in a mathematical sense. 
If you want your numeric values to be interpreted that way, they need to be converted to a numeric class. 
The options typically used are integer (which has no decimal place) and double precision (which has a decimal place). 
Similarly if your data is of class charcter and are values of `TRUE` and `FALSE` they will be interpreted as two different strings. 
However, **logical data** is interpreted slighlty differenlty where a `FALSE` value indicates the absence of something, while a `TRUE` indicates the presence of something.

***
</details>


<details><summary> Click here for more details about the differences between the `recode()` and `case_when()` functions. </summary>


Note, that with `recode()` there is the option that other values be recoded to `NA` althought this is not the default, however with `case_when()` other values not explicitly assigned in the case_when() statement will be assinged to `NA`. Further more only values can be used on the left side when using `recode()` whereas `case_when()` accepts expressions.


***

</details>

To implement the `case_when()` recoding of values, the exisiting values are written on the left of the `~` sign (quotation marks necessary) and new values are written on the right (quotations marks are not necessary as these are `TRUE` and `FALSE` statments). We will also use the `across()` function of the `dplyr` package and the `matches()` function of the `tidyselect` packge to allow us to apply this to all of the variables that have a pattern that that matches any of those of the variables we want to change. The `|` symbol is interpreted as an or, thus any variables that has a name that matches any of these patterns will be changed. fThe `across()` function then applies the `case_when()` function to all of these variables. Notice that the `~` symbol is necessary before the funtion that is applied using `across()`.
```{r}

DT::datatable(shooting_data)
```


```{r}

shooting_data%>% select(matches("Y/N|Specific|Random|Pre-planned"))

shooting_data %>% count( `Suicide (or attempted suicide) by Shooter (Y/N)`)

shooting_data %<>%
       mutate(dplyr::across(.cols = matches("Y/N|Specific|Random|Pre-planned"),
                    ~ dplyr::case_when(. == "Yes" ~ TRUE,
                                         .== "No" ~ FALSE,
                                          .== "Y" ~ TRUE,
                                          .== "N" ~ FALSE,
                          . == "Officer Involved" ~ TRUE)))

shooting_data %>% select(matches("Y/N|Specific|Random|Pre-planned"))

```



#### {.scrollable }
```{r}
str(shooting_data)

```

####

Looks good!



We are also interested in creating a map on our dashboard. 

To do so we need to perform a process called [geocoding](https://en.wikipedia.org/wiki/Geocoding). Geocoding is the process of converting addresses into latitude and longtitude coordinates.

## Geocoding with the `ggmap` package

To peform the geocoding we need the address of each school in the data set. The data currently does not list the actual address, but does have information about the school where the event occured. Since some schools have the same name, we need the city and state data as well. So we will create a new variable in our data called `address` using the `mutate()` function of the `dplyr` package. This variable will collapse the values in the `School`, `City`, and `State` columns but with spaces in between. It is specified that there will be space in between by the `sep = " "` argument. Note that a space is typed between the quotation marks. Then we can use the address variable to look up the latitude and longtitude for each school.


```{r}
shooting_data %<>%
  dplyr::mutate(address = 
          stringr::str_c(School, City, State_abb, sep = " "))

```

Notice that we used a `%>%` in the previous chunk of code. This allows us to create code with a method called piping. 

It allows us to perform many sequential steps efficiently.

***
<details> <summary>Click here if you are unfamiliar with piping in R, which uses this `%>%` operator.</summary>  

By [piping](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) we mean using the `%>%` pipe operator which is accessible after loading the `tidyverse` or several of the packages within the tidyverse like `dplyr` because they load the [`magrittr` package](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html). 
This allows us to perform multiple sequential steps on one data input.
The object on the left side is used as input to any commands to the right or below.

</details>  
***

We can take a look at just this new `address` variable using the `pull()` function of the `dplyr()` package.

#### {.scrollable }
```{r}
shooting_data %>%
  dplyr::pull(address)
```

#### 

Now we can use these addresses to find the latitude and longitude coordinates for each school where a school shooting occured. To do this we will use the `geocode` function of the `ggmap` package to look up these addresses on Google Maps to get the latitude and longitude values. In this command we need to specify that we want to use google as the source using the `source` argument and that we want latitude and longitude using the `output = c("latlon") argument.


This step requires registering with the Google Cloud Platform to get an API key, which currently requires registering your payment information and agreeing to the [Google Maps API Terms of Service](https://developers.google.com/maps/terms).

Therefore, we will simply demonstrate how this process works in general, but you are not required to do this yourself. 

<details><summary> Click here to see how we registered with the Google Cloud Platform.</summary>

If you were to do this process yourself, you could get an API key [here](https://cloud.google.com/maps-platform/). Again this requires registering your payment information, but it is free to got an API key and enable the APIs, however you can be billed based on how many addresses you look up using the APIs. You need to look up thousands before getting billed.

Then you need to enable the maps and places APIs, by clicking on the boxes next to each:

```{r,echo = FALSE}
knitr::include_graphics(here::here("img", "enable.png"))
```

Then you would register like so after copying the API key: (Note this is a fake key)

```{r, eval = FALSE}
ggmap::register_google(key = "mQkzTpiaLYjPqXQBotesgif3EfGL2dbrNVOrogg") 
```

***
</details>


Once we have obtained an API key and registered, we can geocode our data.

Note that this step is time intensive, as there are many addresses to look up! Therefore, we will just show how this is done.

```{r, eval=FALSE}

shooting_data <- shooting_data %>%
  mutate(coords = ggmap::geocode(address, output = c("latlon"), source = c("google")))

readr::write_csv(shooting_data, path = here("processed_data",
                              "shooting_data_geo.csv"))

```

This results in tibble called `coords` being added to our `shooting_data` tibble. That's right we can have a tibble as a column or variable within a tibble.   Using the `glimpse` function again, and looking at the last few variables, we can see that now the last variable listed is `coords` of class `<tibble>`.

```{r,echo = FALSE, out.width="80%"}
knitr::include_graphics(here::here("img", "shooting_data_coords.png"))
```

If we take a look at the first couple of values of the `coords` tibble, using the `slice_head()` function of the dplyr package, we see a tibble that looks like this:


```{r,echo = FALSE, out.width="30%"}
knitr::include_graphics(here::here("img", "coords.png"))
```


It would be better if each of these were their own columns in the tibble, so we will create new `longitude` and `latitude` variables again using the `mutate` function like so:

```{r, eval = FALSE}
shooting_data <- shooting_data %>%
  mutate(longitude = pull(coords,lon),
         latitude = pull(coords,lat))
```

In this case we use the `pull()` function to grab the `lat` and `lon` variables within the `coords` tibble which is a variable of the `shooting_data` tibble.

We can now remove the `coords` tibble like so, using the `select()` funtion of the `dplyr` package:

```{r, eval = FALSE}  
shooting_data <- shooting_data %>%
  dplyr::select(-coords)

```


Now using `glimpse()` and looking at the last several variables, we can see that we no longer have a `coords` variable, but we do have two variables calld `longitude` and `latitude` that are of class double as indicated by the `<dbl>`:

```{r,echo = FALSE, out.width="80%"}
knitr::include_graphics(here::here("img", "double.png"))
```


Now we will save the geocoded data in the `processed_data` directory using the `write_csv` function of the `readr` package.

This requires listing the R object, followed by the path for where the file should be saved and what it should be called. In this case it will be called "shooting_data.csv".

```{r, eval = FALSE} 
readr::write_csv(shooting_data, path = here("processed_data",
                              "shooting_data_geo.csv"))

```


Great now we will work with this data, thus you do not need to get an API key to get to this point. We can read our processed geocoded data into R by using the `read_csv()` function of the `readr` package.

```{r}

shooting_data_geocoded <- read_csv(here("processed_data",
              "shooting_data_geo.csv"))
```



## Geometry lists with the `sf` package

From this section on, we are now going to use a special pipe operator from the [`magrittr` package](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) called the compound assignment pipe-operator or sometimes the double pipe operator, that looks like this `%<>%`. 

This allows us to use the an input and reassign it at the end after all the subsequent steps have been performed. We can therefore use `data_input %<>%` instead of `data_input <- data_input %>%`. We will deomonstrate this in the code below.

We will use the `sf` (which stands for simple features) package to 
create what is called a geometry list of our latitude and longitude information for the schools where shootings occured. This will allow us to deal with the fact that some school shootings occured in the same location, as this will allow us to alter all of the locations a bit so that when we plot the data on a map,  the spots indicating where shootings occured will not overlap for the same location.

The first thing we need to do is create an sf object (meaning an object that the `sf` package recognizes) using the `st_as_sf()` function.

However, to do this we first need to remove rows with `NA` values for the `latitude` and `longitude` variables. In otherwords, we need to remove rows of events that happened at schools with locations that were not identified by google. We can remove this rows using the `drop_na()` function of the `tidyr` package. We will use a `.` to indicate that we want to use the data that we are using as an input with our pipe, but then we will specify that we want to only drop rows were there is an `NA` value for either the `latitude` or `longitude` variables.


```{r}
dim(shooting_data_geocoded)

shooting_data_geocoded %>% filter(is.na(latitude)) %>%select(matches(c("long", "lat", "add")))
```

```{r}

#using previous method:
# shooting_data_geocoded <- shooting_data_geocoded %>%
#    tidyr::drop_na(., c(latitude, longitude))

#using magrittr %<>% compound assignment pipe-operator
shooting_data_geocoded %<>%
 tidyr::drop_na(., c(latitude, longitude))
```

```{r, eval = FALSE}
dim(shooting_data_geocoded)

cols_to_select <-c("School","Date","State", "City", "Narrative (Detailed Summary/ Background)", "Killed (includes shooter)")

setdiff(select(shooting_data, cols_to_select),
        select(shooting_data_geocoded, cols_to_select))
```


Now let's take a look at the variables in our data related to location by using the `select()` function of the `dplyr` package:

```{r}
shooting_data_geocoded %>%
  select(School, City, State, latitude, longitude)
```

We can see (using the base `dim()` function) that the dimensions were 1156 rows of 51 variables, but they are now 1551 rows of 50 variables. This is becuase 5 events occured at schools with unidentified complete locations (missing either latitude, longitude, or both). 

Now, we are ready to convert our coordinates variables (`latitude` and `longitude`) into a coordiante simple feature using the `st_as_sf()` function. We need to specify what our coordinate variables are and we will also specify what [coordinate reference system](https://www.w3.org/2015/spatial/wiki/Coordinate_Reference_Systems),(crs) we would like to use. In our case we will use the [ESPG](https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset) reference number [4326](https://spatialreference.org/ref/epsg/4326/), known as ESPG:4326 or the [World Geodetic System (WGS) version 84](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84) which is one of the most commonly used CPS and used by by most global positioning systems, known as GPS. **This tells R  to use the values for the variables called `latitude` and `longitude` as latitude and longitude coordinates.**

```{r}
shooting_data_geocoded %<>%
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

dim(shooting_data_geocoded)

```

We can see that our `latitude` and `longitude` variables were used to create a single new variable called `geometry` of class  `<POINT` [$^{\circ}$]`>`, thus we have one less column.

In this case, we can take a look at just the first 4 variables and we will also see our last `sf` variable as well appeneded at the end. So now we can see the variables related to location by simply typing `[1:4]` next to the name of our tibble `shooting_data_geocoded`.

```{r}
shooting_data_geocoded[1:4]
```


Now to allow our points to not overlap for events that took place in the same location, we will add a bit more range so that they don't overlap one another on our map, we will transform the coordinates using the `st_transform()` function  of the `sf` package into a two dimensional projection (called the [Albers equal-area conic projection](https://en.wikipedia.org/wiki/Albers_projection#:~:text=The%20Albers%20equal%2Darea%20conic,that%20uses%20two%20standard%20parallels.&text=The%20Albers%20projection%20is%20used,the%20United%20States%20Census%20Bureau.)) with units in meters using the [crs 102008](https://spatialreference.org/ref/esri/102008/html/) and then use the `st_jitter()` of the `sf` package function
to allow a specified amount of range near the actual original GPS coordinates. In this case we will allow for 50 meters of range.

To learn more about geospatial coordinate systems see [here](https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf) and [here](https://guides.library.duke.edu/r-geospatial/CRS).

So here we can see the output after transforming our data:

```{r}
shooting_data_geocoded  %<>%
  st_transform(crs = 102008) 
```

```{r}
shooting_data_geocoded[1:4]
```
And here we can see the output after adding the jitter:

```{r}
shooting_data_geocoded  %<>%
   st_jitter(amount = 50)

shooting_data_geocoded[1:4]
```

Notice how the `geometry` values have changed.

Now we will transform our coordinates back into the 3D latitude and longitude degree system again using the `st_transform()` function and the [ESPG:4326](https://spatialreference.org/ref/epsg/4326/), corrdinate system.

```{r}
shooting_data_geocoded  %<>%
  st_transform(crs = 4326)

shooting_data_geocoded[1:4]
```

Notice how the `geometry` variables are different from what they were orginally with this coordinate system:

```{r, echo = FALSE, out.width= "90%"}
knitr::include_graphics(here::here("img", "geometry.png"))
```


Now we will separate the `geometry` variable into `longitude` and `latitude` variables again. We can use the ` st_coordinates()` function of the `sf` package to extract the coordinates from our tibble as a matrix.

```{r}
shooting_data_geocoded %<>% 
  mutate(coordinates = as.tibble(st_coordinates(.)))

shooting_data_geocoded %>%
  pull(coordinates) %>%
  slice_head(n = 4)
```

Now, just as we did previously we will create new variables called `latitude` and `longitude` from the `X` and `Y` variables within the `coordinates` tibble that is part of our `shooting_data_geocoded` using the `pull()` function.

We will also convert our `shooting_data_geocoded` object which is currently a `sf` into a tibble using the `as_tibble()` function of the `tibble` package and then we will remove the `geometry` and `coordinates` variables using the `select()` function of the `dplyr` package with a negative sign infront of the names of the variables to remove.

```{r}
shooting_data_geocoded %<>%
  mutate(longitude = pull(coordinates,X),
          latitude = pull(coordinates,Y)) %>%
  tibble::as_tibble() %>%
  select(-geometry) %>%
  select(-coordinates)
```

And now we can take a look at  our last 3 variables using the `last_col()` function, which is a select helper function `tidyr` package. See [here](https://tidyselect.r-lib.org/reference/select_helpers.html) for other select helper functions. This allows us to select either the last column, or with a specified offset we can select a number of columns before the last column. Thus 2 columns before the last column  would be `last_col(offset = 2)` and then the `:` symbol is interpreted as through, thus we are selecting for the third to last column through the last column with `last_col(offset = 2): last_col()`.

```{r}
shooting_data_geocoded %>% 
  select(last_col(offset = 2):last_col()) %>% 
  slice_head(n = 4)

```


Great! That looks like we expected. We can see that the coordinate values are slightly different now.

```{r}
original_shooting_data_geocoded <- read_csv(here("processed_data",
              "shooting_data.csv"))

original_shooting_data_geocoded %>%select(longitude, latitude) %>% slice_head(n = 4)
```




#### {.scrollable }
```{r}
str(shooting_data_geocoded)

```

####

Looks good!

Now we will save our wrangled data, again using `write_csv()`.

```{r, eval = FALSE}

readr::write_csv(shooting_data, path = here("processed_data",
                              "shooting_data_pre_geo_wrangled.csv"))
write_csv(shooting_data_geocoded, path = here("processed_data",
                                 "shooting_data_wrangled.csv"))
```


# **Data Analysis and Visualization**
*** 

First let's load the data by reading in our wrangled version of the data.

```{r}
shooting_data <- read_csv(here("processed_data",
                                        "shooting_data_pre_geo_wrangled.csv"))

shooting_data_geocoded <- read_csv(here("processed_data",
                                        "shooting_data_wrangled.csv"))
```


There are several elements we would like to include in our dashboard. 

One thing we would like is an interactive table.

### Interactive Table

We can done so using the `datatable()` function of the `DT` package.

```{r, eval = FALSE}
DT::datatable(shooting_data)
```
This creates a searchable table and the order in which the data is displayed can be toggled to change for each variable.

However, we have many varaibles, so this get's to be overwhelming. Since there are so many this even modifies the way the rmarkdown for this case study is rendered, thus instead of displaying all of the variables, let's choose only some of the most interesting to display on our dashboard.


```{r}
DT_table <- shooting_data%>%
  dplyr::select(Date,
                School,
                City,
                State,
                `Killed (includes shooter)`,
                `Narrative (Detailed Summary/ Background)`) %>%
  rename("Deaths" = `Killed (includes shooter)`) %>%
  rename("Narrative" = `Narrative (Detailed Summary/ Background)`)

DT::datatable(DT_table)
```


Now we would also like to make some visualizations of our data.

## Yearly Shootings

First, we would like to create a plot of the number of shootings per year.

To do this we will first count the number of shootings per year by using the `group_by()` function  and the `count()` function of the `dplyr` package. The `group_by()` functions allows us to summarize the data across specific groups specified by a variable or multiple variables. By grouping by `Date_year` we can then use the `count()` function to count the number of rows with shooting event information 
for each unique value of the `Date_year` variable.

We then want to use the `ungroup()` function to get the data out of this grouping based on the `Data_year` varaible.


```{r}

shootings_per_year<- shooting_data %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()


shootings_per_year

```
Nice looks good!

Now to make a plot of this data we will use the `ggplot2` package.

<details><summary> Click here for an introduction about this package if you are  new to using `ggplot2` </summary>

The [ggplot2 package](http://ggplot2.tidyverse.org) is generally intuitive for beginners because it is based on a  [grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html) or the `gg` in `ggplot2`. 
The idea is that you can construct many sentences by learning just a few nouns, adjectives, and verbs. There are specific “words” that we will need to learn and once we do, you will be able to create (or “write”) hundreds of different plots.

The critical part to making graphics using `ggplot2` is the data needs to be in a _tidy_ format. 
Given that we have just spent time putting our data in _tidy_ format, we are primed to take advantage of all that `ggplot2` has to offer! 

We will show how it is easy to pipe _tidy_ data (output) as input to other functions that create plots. 
This all works because we are working 
within the _tidyverse_. 

**What is the `ggplot()` function?** 
As explained by Hadley Wickham:

> The grammar tells us that a statistical graphic is a mapping from data to aesthetic attributes (colour, shape, size) of geometric objects (points, lines, bars). The plot may also contain statistical transformations of the data and is drawn on a specific coordinates system.

`ggplot2` Terminology: 

- **ggplot** - the main function where you specify the dataset and variables to plot (this is where we define the `x` and
`y` variable names)
- **geoms** - geometric objects
    - e.g. `geom_point()`, `geom_bar()`, `geom_line()`, `geom_histogram()`
- **aes** - aesthetics
    - shape, transparency, color, fill, line types
- **scales** - define how your data will be plotted
    - continuous, discrete, log, etc

The function `aes()` is an aesthetic mapping function inside the `ggplot()` object. 
We use this function to specify plot attributes (e.g. `x` and `y` variable names) that will not change as we add more layers.  

Anything that goes in the `ggplot()` object becomes a global setting. 
From there, we use the `geom` objects to add more layers to the base `ggplot()` object. 
These will define what we are interested in illustrating using the data.

***
</details>

For more of an introduction on creating plots with `ggplot2` , see this [case study]()

First, we start with the `ggplot()` function of the `ggplot2` package.

This function requires that the aesthetics `aes()` be specified. This involves choosing what variable will be plotted on the x-axis and the y axis. 

This will create an empty plot area, next we need to use one of the `geom*` functions of the `ggplot2` package to specify what type of plot we want to create.

Type geom into the RStudio console and you will see many options to scroll through.

We will be creating a `geom_col()` plot, which is a particular type of bar plot that uses the acutal values to plot, rather than counts, which is the default of `geom_bar()` We will specify with the `fill` argument, that we want our bars to be filled with the color black.

We will also modify the x-axis using the `scale_x_continuous()` function. This function allows for specification of the range or limits of the axis using the `limits` argument. We can use the base `seq()` function to create a sequence of numbers for each tick mark.


We can add labels to our plot using the `labs()` function of `ggplot2`. This has arguments such as `x` and `y` for the axes and `title` and `subtitle` for titles.

We will also modify the overall aesthetics of the plot using a `theme_*` function. See [here](https://ggplot2.tidyverse.org/reference/ggtheme.html) for a list of options.

```{r}
start <- 1970
end <- 2020


shootings_per_year_p <-shootings_per_year %>%
    ggplot(aes(x = Date_year, y = Shootings)) +
    geom_col( fill = "black") +
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
      labs(title = "Yearly School Shootings",

   # labs(title = "Yearly Deaths Attributable to School Shootings",
         subtitle = "United States",
         x = "",
         y = "School Shootings")

shootings_per_year_p 
```

## Yearly Deaths

Notice that when using summarize we dont use mutate here.
```{r}

deaths_per_year<-shooting_data %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))

deaths_per_year_p <-deaths_per_year %>%
    ggplot(aes(x = Date_year, y = Deaths)) +
    geom_col( fill = "black")+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
   labs(title = "Yearly Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = "School Shootings",
         x = "")
deaths_per_year_p


```

Ok, we want to make a plot that shows both the number of shootings per year and the number of deaths.

We can do so by combining our `shootings_per_year` and  `deaths_per_year` tibbles together and making what is called a faceted plot.

To combine our data we will use the `full_join()` function of the `dplyr` package. This maintains all values from both tibbles.




To do so we will be making our table "longer", meaning that it will have fewer columns and more rows. 
See [here](https://en.wikipedia.org/wiki/Wide_and_narrow_data) for more information about different table formats, typically referred to as wide and long or sometimes narrow.

We will use the `pivot_longer()` function of the `tidyr` package to change the shape of our table. 

There are 3 main arguments in this function:   

1. `cols` - which specifies what columns to collapse  
2. `names_to` - which specifies the name of the new column that will be created that will contain the column names of the columns you are collapsing  
3. `values_to` - which specifies the name of the new column that will be created that will contain the values from the columns you are collapsing 

To specify that we want to collapse all the columns that have year values, we can chose  all those except the `Date_year` variable by  using the `-` minus sign. 

We will also use the `fct_inorder()` function of the `forcats` package to reorder our `id` varible` to the order in which they appear first rather than by alphabetical order (which is default). Thus the number of shootings will appear on the left side (first) rather then on the right.

```{r}

per_year<-full_join(shootings_per_year, deaths_per_year)
per_year %<>%pivot_longer( cols = -Date_year, 
                           values_to = "events", 
                           names_to = "id")

per_year%<>% 
  mutate(id = forcats::fct_inorder(id))

per_year %>%
ggplot(aes(x = Date_year, y = events, fill =id)) +
  geom_col()+
  facet_grid(~id)+
  scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
  theme_minimal() +
  labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = "Number of events",
         x = "Year")+
  scale_fill_manual(values = c("black", "black"))+
  theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background =element_rect(fill="cornflowerblue"),
        strip.text = element_text(colour = 'white', face = "bold", size = 14))
 


```

## Yearly Cumulative Shootings

Now let's make another plot of the cumulative deaths each year including those of the previous years. In this case we can use the `shooting_per_year` object that we previously made. We want to add a new variable using the `mutate` function called `n_cum_sum` by using the `cumsum()` function to calculate a cumulative sum based on the yearly count. 



```{r}

shootings_per_year

shootings_per_year_cum <- shootings_per_year%>%
    mutate(Shootings = cumsum(Shootings))

shootings_per_year_cum 

deaths_per_year_cum <- deaths_per_year%>%
    mutate(Deaths = cumsum(Deaths))

shootings_per_year_cum 



per_year_cum <- full_join(shootings_per_year_cum, deaths_per_year_cum)


per_year_cum %<>%pivot_longer(cols = c(Shootings,
                                        Deaths ), 
                           values_to = "events", 
                           names_to = "id")

per_year_cum
```

Good, this looks like we would expect.

Now let's make a plot like we did before:

```{r}
per_year_cum %<>% 
  mutate(id = forcats::fct_inorder(id))

per_year_cum %>%
    ggplot(aes(x = Date_year, y = events, fill =id)) +
    #geom_col(aes(fill = id), position = "dodge") +
  geom_col()+
  facet_grid(~id)+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
   labs(title = "Cumulative Yearly Shootings and Deaths\nAttributable to School Shootings",
         subtitle = "United States",
         y = "Cumulative number of events",
         x = "Year") +
  scale_fill_manual(values = c("black", "black"))+
  theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background =element_rect(fill="cornflowerblue"),
        strip.text = element_text(colour = 'white', face = "bold", size = 14))
 

```


## Deaths per Shooting

Now, lets make a plot of the number of deaths per shooting based on the `Killed (includes shooter)` varaible. Our first plot could also have been made using `geom_bar()` instead of `geom_col()` this makes a similar plot but automatically uses the count for one of the axes. 

```{r}
# This is equivalent:
# deaths_per_event <- shooting_data %>%
#     group_by(`Killed (includes shooter)`) %>%
#     count() %>%
#     ungroup()
# 
# deaths_per_event %>%
#     ggplot(aes(y = `Killed (includes shooter)`, x = n)) +
#     geom_col(fill = "black")+
#     theme_minimal() +
#     labs(title = "Deaths per School Shooting",
#          subtitle = "United States",
#          x = "School Shootings",
#          y = "")

shooting_data %>%
    ggplot(aes(x = `Killed (includes shooter)`)) +
    geom_bar(fill = "black") +
  # scale_x_continuous(breaks = seq(0,10, by = 1),
  #                    labels = seq(0,10, by = 1),
  #                    limits = c(-1,10)) +
    theme_minimal() +
    labs(title = "Deaths per School Shooting",
         subtitle = "United States",
         x = "School Shootings",
         y = "")

```
It is a bit difficult to see the shootings that had more numerious deaths, so we will add a facet that zooms in on this portion of the plot. We can do so, using the `facet_zoom()` function of the `ggforce` package.

```{r}
library(ggforce)


shooting_data %>%
    ggplot(aes(x = `Killed (includes shooter)`)) +
    geom_bar(fill = "black") +
   scale_x_continuous(breaks = seq(0, max(pull(shooting_data, `Killed (includes shooter)`)), by = 1),
                      labels = seq(0, max(pull(shooting_data, `Killed (includes shooter)`)), by = 1))+
  #                    limits = c(-1,10)) +
ggforce::facet_zoom(xlim = c(4, max(pull(shooting_data, `Killed (includes shooter)`))), ylim = c(0,20))+
theme_minimal() +
    labs(title = "Deaths per School Shooting",
         subtitle = "United States",
         x = "Deaths per shooting",
         y = "Number of events with given number of deaths")+
  theme(axis.text.x = element_text(angle = 90))
```

This is still a bit difficult to interpret. Let's try some other options.

The `geom_freqpoly()` function creates a graph that makes it very easy to see that most shootings result in zero or one death and that the maximum number of deaths in this data for a single event is in the upper twenties. 
```{r}

shooting_data %>%
    ggplot(aes(x = `Killed (includes shooter)`)) +
    geom_freqpoly()
```

This really shows that most shooting events luckily result in no deaths, but what are the actual proportions. One way to look at this is to calucate the percentage of events that resulted in each number of deaths. We can do so by dividing the number of events by the overal sum of events and multiplying by 100. The base `round()` function can round this value to the nearest 1 decimal place by specifying that we want 1 digit after the decimal with `digits = 1`.


```{r}
deaths_perc_event <-shooting_data %>%
   count(`Killed (includes shooter)`) %>%
   rename("num_events"= n) %>%
   mutate(percent = round(num_events/sum(num_events)*100, digits =1))

deaths_perc_event

deaths_perc_event %>%
  ggplot(aes(x =`Killed (includes shooter)` , y = percent)) +
    geom_col()
```

Ok, this is easier to interpret than the raw count values. We can see that greater than 60% of the events had no deaths. It is however, still a bit difficult to interpret.

So now, we will also collapse the events that resulted in 4 or more deaths together and we will create a pie chart which you are likely familiar with as well as alternative plot called a waffle plot.


First to collapse the percentage for the events that had 4 or more deaths, we need to do a bit of wrangling.

We will start with filtering the data to only these events and then we will sum  each of the columns using the base `colSums()` function with the goal of creating a new row in the `deaths_perc_event` object that will contain information about all events with 4 or more deaths. We will use the `>=` greater than or equal to opperator.

```{r}
greater_than4<-deaths_perc_event %>% 
  filter(`Killed (includes shooter)` >= 4) %>% 
  colSums()

greater_than4

```
Good, now we know the overall percentage for the events that unforuntately resulted in a larger number of deaths. 

Now we can combine this with the rest of our data using the `bind_rows()` function of the `dplyr` package which appends a tibble to another.



```{r, echo = FALSE, outwidth = "40%"}
knitr::include_graphics(here::here("img", "bindrows.png"))
```

##### [[source]](https://rstudio.com/resources/cheatsheets/)


```{r}
deaths_perc_event %<>%  bind_rows(greater_than4)

deaths_perc_event 
```

Now we want to add a new variable so that it is easy to plot and interpet the number of deaths for each percentage. We will simply add the word "deaths" to each value in the `Killed (includes shooter)` variable using the base `paste0()` function. Note that this function automatically will result in no space or any other character between pasted elements. The `paste()` function can alternatively be used for those cases. 

```{r}
deaths_perc_event %<>% mutate(category = paste0(`Killed (includes shooter)`, " deaths ", "(", percent, "%)")) 

deaths_perc_event
```

We would like to change the value for the last row about the events that resulted in 4+ deaths. 

We can use the `last()` function of the `dplyr` package combined with the `pull()` function to specifically grab this value.

```{r}
last(pull(deaths_perc_event, category))

```


Now we can use the `case_when()` function yet again to change this value. Note that we could have used a stringr function to replace the specific value of "85 deaths", but this would not be reproducible. Say we used this code again after the data got updated. Then there may be more deaths in this category and therefore this value would no longer be "85 deaths". Instead, by using `case_when()`, we can use an expression for the last value of the `deaths_perc_event` tibble and replace that, regardless of what the value is, with "4+deaths". Recall that `case_when()` replaces all other values that are not specified with `NA`. We do not want to lose the other values for the `category` variable. So to avoid this, we assign each of the values that are not the last value or the `"1 deaths"` value to what they currently are for the `category` variable, using `TRUE ~ category` (Note that all remaining unassigned values are indicated as `TRUE`).

Note that we could actually type out the percentage of 4+death cases, but it is always more reproducible to instead use an expression that will evaluate to the value we want. This way if we were to update our data with additional shooting events, this evaluation would also update.

```{r}
deaths_perc_event %<>% 
  mutate(category = case_when(
    category ==  last(pull(deaths_perc_event, category)) ~ paste0("4+ deaths ", "(", percent, "%)"),
    category == "1 deaths" ~ "1 death",
    TRUE ~ category))

deaths_perc_event
```

Looks as we hoped. OK, now we are ready to make more plots. 

First we will start with the pie chart. This is a bit of a controversial type of plot. However, it can be very useful when you are actually looking at percentages and the goal is to see major trends in the data, such as all the groups are roughly equal or one group is particularly larger than the rest. When this is the case and you are presenting the data to an audiance that is less familiar with data science, they may expect to see a pie chart. Thus it is useful to know how to make one. However, in most other cases pie charts do a poor job at allowing us to see more subtle differences, and they are particularly confusing when we are not looking at proportions but raw counts. In those cases it is better to use a bar chart as we have already done. 

There is no `geom_*` function that allows you to create a pie chart directly. Instead we will create our bar plot as we have and then use the `coord_polar()` function to wrap our y axis into a circular shape.

```{r}
deaths_perc_event %>%
  filter(percent>0.5) %>%
    ggplot(aes(x = "", y = percent, fill = category)) +
  # adding color here adds a black outline
    geom_col(color = "black") +
    coord_polar("y", start = 0) +
  scale_y_continuous(breaks= NULL)+
  theme_minimal()+
  theme(axis.title = element_blank())+
  scale_fill_viridis_d()+
  labs(title = "Percentages of school shooting deaths\n(including the shooter)")

```

This is actually a fairly easy plot to interpret. We can see that most events resulted in zero deaths and that the next largest proportion resulted in one death, while a sizable but small proportion resulted in two deaths. A very small proportion resulted in three or four or more deaths.

Now we will also create a waffle plot. This plot offers one advantage over the pie chart, in that it also allows for easier interpretation of more subtle proportion differences while also showing big picture differences in efficent manner. 
First we need to filter for only the data that we want to plot. We only want the 0,1,2,3, or 4+ categories. We can do so by using the `str_detect()` function of the `stringr` package. This allows us to find the values that match multiple patterns. The patterns are separted by the `|` or opperator. Thus any value matching any of the patterns should be kept. 

The `waffle()` function requires that the data be in wide format. Thus we need to use `pivot_wider()` of the `tidyr` package to do so. This is very similar to the `pivot_longer()` function, however in this case we need to specify what existing column contains the names for the new columns using `names_from` and what existing column contains the values for the new columns using `values_from`. 

```{r}
library(waffle)

deaths_perc_event %>% select(-`Killed (includes shooter)`) %>%
  filter(str_detect(category, "0 deaths|1 death|2 deaths|3 deaths|4+")) %>%
  mutate(percent = round(percent)) %>%
  select(-num_events) %>%
  tidyr::pivot_wider(names_from = category, 
                    values_from = percent) %>%
  waffle::waffle(legend_pos = "bottom", title="Deaths Per School Shooting", 
       xlab="1 square ~ 1%") +  scale_fill_viridis_d()

```

We are also interested in including some statistics in our dashboard. For example we are interested in how many shooters committed or attempted suicide.

### Percentages

Since we converted variables with `yes` or `no` answers because they were inconsistently coded as `yes`/ `y` and `no`/`n`.  Futhermore, logical variables are easier to work with in terms of performing calculations because `TRUE` values are treated like a `1` while `FALSE` values are treated like a `0`. 

We would like to calculate the percentage of shooters that committed or attempted suicide out of all entries that have data for this information, thus we don't want to include `NA` values in the calculation. 

Let's take a look at the data for this variable:

```{r}
shooting_data %>% count(`Suicide (or attempted suicide) by Shooter (Y/N)`)
```

We can see that there are 45 `NA` values. 


If we calculate a sum of the `TRUE` values, (which are those that are equivalent to `1`), we can do so by just summing this variable, which is equivalent to summing values that are greater than `0`. 

```{r}
sum(pull(shooting_data,`Suicide (or attempted suicide) by Shooter (Y/N)`), na.rm = TRUE)
sum(pull(shooting_data,`Suicide (or attempted suicide) by Shooter (Y/N)`) > 0, na.rm = TRUE)
```

In contrast, `FALSE` values are those that are equvialent to `0`. Thus if we want to divide by the sum of all values that are `FALSE` are `TRUE`, then we can sum all values greater than or equal to `0`.

```{r}
sum(pull(shooting_data,`Suicide (or attempted suicide) by Shooter (Y/N)`) >= 0, na.rm = TRUE)
```

Thus we can calculate the percentage of all reporting values like so, where the `TRUE` values are divided by the sum of all `TRUE` and `FALSE` values: (We also multiply by 100 using `*100` to get the percentage value.) 

```{r}
suicide <-(sum(pull(shooting_data,`Suicide (or attempted suicide) by Shooter (Y/N)`), na.rm = TRUE) /
           sum(pull(shooting_data, `Suicide (or attempted suicide) by Shooter (Y/N)`)>=0, na.rm = TRUE))*100
```


# **Dashboard Basics**
***

OK, now we have our data and our plots for our dashboard!

Now we will introduce some basics about creating dashboards in R with the `flexdashboard` package.


## Dashboard packages
To make our dashboard we will use three very useful packages:

1) [flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/)

Flexdashboard is a package that was created by RStudio and [released](https://blog.rstudio.com/2016/05/17/flexdashboard-easy-interactive-dashboards-for-r/) in May of 2016. This package allows for users to more easily create dashboards using [R markdown](http://rmarkdown.rstudio.com/). 

See [here](https://rstudio.com/resources/webinars/introducing-flexdashboards/) for a video about flexdashboard and [here](https://rmarkdown.rstudio.com/flexdashboard/) for a more information on how to use this package.

2) [leaflet](https://rstudio.github.io/leaflet/)

[Leaflet](https://leafletjs.com/) is the leading open-source JavaScript library for interactive maps and is used by many websites. The [leaflet](https://rstudio.github.io/leaflet/) R package allows for users to more easily integrate leaflet maps in R, to create maps like the one below. We will use this package to create a map of where school shootings have occured in the US.

```{r,echo=FALSE}
library(maps)
mapStates = map("state", fill = TRUE, plot = FALSE)
leaflet(data = mapStates) %>% addTiles() %>%
  addPolygons(fillColor = topo.colors(10, alpha = NULL), stroke = FALSE)
```


3) [shiny](https://shiny.rstudio.com/)

[Shiny](https://shiny.rstudio.com/) is an R package that makes it easier to create interactive web applications in R. See [here](https://shiny.rstudio.com/gallery/) for a gallery of examples. People have created a variety of diverse applications using this package- from [interactive websites](https://shiny.rstudio.com/gallery/real-estate-investment.html) to [games](https://shiny.rstudio.com/gallery/hex-memory.html).

```{r, echo = FALSE, out.width= "60%"}
knitr::include_graphics(here::here("img", "game.png"))
```

##### [[source]](https://shiny.rstudio.com/gallery/hex-memory.html)

See [here](https://rmarkdown.rstudio.com/flexdashboard/using.html#components) for a list of other packages that are useful for adding elements to dashboards created with the `flexdashboard` package.

***

## R Markdown

The case study that you are reading right now was created using an [R Markdown document](https://rmarkdown.rstudio.com/). This means that it is a document that uses the `Markdown` language syntax. 

In fact if you click the button that says "code" on the upper right corner you will download the [R Markdown](https://rmarkdown.rstudio.com/articles_intro.html#:~:text=R%20Markdown%20is%20a%20file,code%2C%20like%20the%20document%20below.) document for this case study. 

[R Markdown (Rmd)](https://rmarkdown.rstudio.com/articles_intro.html#:~:text=R%20Markdown%20is%20a%20file,code%2C%20like%20the%20document%20below.) is a file format that contains Markdown sytax and embedded R code (it can also incoperate code from some other languages like [Python](https://en.wikipedia.org/wiki/Python_(programming_language)) and [SQL](https://en.wikipedia.org/wiki/SQL)).




```{r}
library("vembedr")
embed_url("https://vimeo.com/178485416") %>%
  div(class = "vembedr") %>%
  div(align = "center")
```

##### [[source]](https://rmarkdown.rstudio.com/lesson-1.html) 

These Rmd files are rendered into a variety of file outputs like PDF, word, HTML etc. by the  [`knitr`](https://yihui.org/knitr/) and [`rmarkdown`](https://cran.r-project.org/web/packages/rmarkdown/rmarkdown.pdf) packages.

This relies on conversion of the Rmd file into the [Markdown](https://en.wikipedia.org/wiki/Markdown) language by software called [Pandoc](https://en.wikipedia.org/wiki/Pandoc).

[Markdown](https://en.wikipedia.org/wiki/Markdown) (which has been implemented by many languages, such as [Perl](https://en.wikipedia.org/wiki/Perl), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)), etc.) is a language of a particular class of programming languages called [lightweight markup languages(LML)](https://en.wikipedia.org/wiki/Lightweight_markup_language). 

LMLs have relatively simple and intuative syntax, and are therefore relatively easy to write and read and are converted by software into some type of less human-freindly language to create an ouput document like a PDF or an HTML file.  In fact, multiple output files can be created from the same LML file!

In our case we are interested in rendering our Rmd document into a website. Thus the code in our R Markdown document will be interpreted and converted ultimately into html code.

Although LMLs tend to be quite similar, here you can see some of the differences in syntax:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "syntax.png"))
```

##### [[source]](https://en.wikipedia.org/wiki/Lightweight_markup_language)

See this [book](https://bookdown.org/yihui/rmarkdown/) for more information on working with R Markdown files. 

The RStudio [cheatsheet for R Markdown](https://github.com/rstudio/cheatsheets/raw/master/rmarkdown-2.0.pdf) and this [tutorial](https://ourcodingclub.github.io/tutorials/rmarkdown/) are great for getting started. 

avocado- how do you feel about including this tutorial - it is very good - and not code academy- but I am not familiar with the coding club but they seem like a nice group 


## Flexdashboard

There are several important features about the R markdown that the `flexdashboard` package utilizes. 

These are used to specify the layout and elements of the dashboard.

Here are some major R markdown features to keep in mind for `flexdashboard`

1) The beginning of an R markdown document is what is called the [YAML](https://en.wikipedia.org/wiki/YAML) header. This is delinated by `---` three dashmarks before and after the header YAML code.

Like so:
```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "yaml.png"))
```

##### [[source]](https://ourcodingclub.github.io/tutorials/rmarkdown/)

[YAML](https://en.wikipedia.org/wiki/YAML) is yet another language, but unlike Markdown it is a data-oriented language and is often used for the [configuration](https://en.wikipedia.org/wiki/Configuration_file) of software or to set up how a software program should work.

Thus whatever code you put in the YAML header will inclufuence the rest of the document and essentially set up how the R markdown document will render. In the example the type of output is specified.

But other more complicated features can be included. For example, we can specify that we are creating a dashboard with flexdashboard and we can specify how we want the layout of our dashboard to be displayed like so:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "yaml_dashboard.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

We will describe this in more detail soon.

2) To add a page to a navigation bar (also called a navbar) the following syntax is used `=======`. The number of dashes does not matter. (This is a level 1 header in markdown, just like `#`)


3) To add columns or rows the following syntax is used `---------`. By default this notation will create new columns, however if the YAML is modifed to specify to create rows, than this same sytnax will be used to create rows. The number of dashes does not matter. (This is a level 2 header in markdown, just like `##`) avocado - you can also set a page to be rowwise


4) Components within the dashboard are delinated by using `###` - if you are familiar with markdown notation, this is a level 3 markdown header.

If this includes text like so: `### text`, this adds header text to the component, however this is not required. 


5) To  include a plot or any output from R, use the following syntax:
`"```{r}"` on it's own line followed by your code, followed by `"```"`. This creates what is called a code chunk.

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "code_chunk.png"))
```

##### [[source]](https://ourcodingclub.github.io/tutorials/rmarkdown/)


6)  Another component of flexdashboards is value boxes. These are essentially text boxes for statistics  or text that you  might like feature or emphasize. To do this again the `###` syntax is used to put a text label describing what the value box contains followed by a code chunk that uses the `valueBox()` function of the `flexdasboard` package. The value to display is specified using the `value` argument, as well as optional other aspects using additional arguments, such as the color of the value box using the `color` argument like the example below:

```
### ValueBoxText

'''{r}
valueBox(value = 10
  color = "white")

'''
```

Note that in our examples of code we will use `"'''"` instead of `"```"`. This is only to allow for easy viewing of examples. All code chunks require `"```"`.

Here you can see a more thurough example which includes icons:
```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "valuebox.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/using.html#value_boxes)

6) Instead of value boxes you can also include a slight variation called a guage. These are created with the `guage()` function of the `flexdashboard` package. This requires numeric values for a `value`, a `min`, and a `max` argument. Optionally, a symbol can also be added with the `symbol` argument. The value argument does not have to be explicitly called though, which is also true of the `valueBox()` function.

Here is a simple example:

```
### GuageText

'''{r}
flexdashboard::gauge(value = 10, 
                       min = 0, 
                       max = 100, 
                    symbol = "%")

'''
```

This creates the following output:
```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "guage_output.png"))
```

Here is a more complicated example:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "guage.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/using.html#value_boxes)

## Layout

### Adding Columns

To add multiple columns the following syntax is used `---------` for each  column and nothing additional is required in the header.

Additional features about the columns, such as the width can be specified using brackets`{}`like in the example below. Note that the word `Column` isn't necessary. In this example two columns are created that will be oriented next to one another and elements within the columns will be placed top to bottom. 

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "columns.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)


### Adding Rows
To add multiple rows - the yaml needs to state that the orientation is for rows instead of for columns (see the image below),  and then the same syntax is used `---------`  for each row instead of columns. In this example two rows are created that will be oriented on top of one another and elements within the rows will be placed next to eachother.

Again the word `Row` is not actually necessary.

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "rows.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

See [here](https://rmarkdown.rstudio.com/flexdashboard/layouts.html) for template options.


### Tabs

To add tabs columns/rows we can use the following: 

```
Column {.tabset}
```

Here is an example, where two columns are created and then two tabs are added to the second column.

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "tab.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

### Shiny

Interactive elements can be added to flexdashboards. In our dashboard we will use packages such as `DT` and `Leaflet` that have shiny functionality. This requires that shiny is enabled in the YAML header by including `runtime:shiny` in the YAML.

Here is an example of a YML that includes this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "shiny_yml.png"))
```

***

# **Our Dashboard**
***

OK! Now that we know a bit about the basics of creating a dashboard, let's create our own.

We want to create a dashboard that has several tabs that will look like this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "dashboard_school.png"))
```

## Getting started

The first thing we need to do to create our dashboard is to create a new .Rmd document like so in R Studio:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "newrmd.png"))
```


## YAML header

Next we need to update the YAML header to look like this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "our_yaml.png"))
```


As you might expect, `title:` indicates the title of our dashboard.

The `output:` line specifies what type of output we want the .Rmd file to be rendered.

We need to include `flexdashboard::flex_dashboard:` as the output to create a dashboard with the `flexdashboard` package. This can be included on the same line as `output:` or on the next line with a preceding tab.

Note that YAML is sensative to spacing, thus this tab is required to get the proper output.

Then the next four lines are arguments for how the dashboard should be created.

1) `logo:` allows you to include a logo on top of your dashboard. With this theme this will be in the upper left corner. The logo we chose to use came from [here](https://iconarchive.com/), but you could theoretically use any png of appropriate size.

2) `theme:` allows you to specify how the dashboard will look in general. Note that this can be used to modify the genearl look of any type of R Markdown output, not just flexdashboards. See [here](https://www.datadreaming.org/post/r-markdown-theme-gallery/) for a list of options. In our case the theme is called readable and will create documents that look like this:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "readable.png"))
```

##### [[source]](https://www.datadreaming.org/post/r-markdown-theme-gallery/)

3) `orientation:` the options are `columns` or `rows` and specifies if the `--------` syntax creates rows or columns for the layout. This is not necessary if the option is `columns`.

4) `source_code:` specifies if a URL will be included as a navigation bar item with access to the source code. 

5) `vertical_layout:` The options are `fill` or `scroll`. Fill causes the charts to resize to fill the page, while the scroll option renders plots as their natural height which may or may not require scrolling the page.

There are many other argument options for how the dashboard is displayed.

You can run the following command in the console to see more information about the arguments in the help pane of the R Studio [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment).

```{r}
?flexdashboard::flex_dashboard()
```

Also see the cran [documentation](https://cran.r-project.org/web/packages/flexdashboard/flexdashboard.pdf) for more details.

## Loading the packages and data

Since we are creating our dashboard in a new Rmd file, we need to load the necessary packages and the wrangled data that we created in this Rmd file. In that Rmd file, it looks something like this. Note that all the rest of the code shown would be added to the Rmd file for the dashboard and are simply shown here for illustrative purposes.

```{r,eval = FALSE}
library(googlesheets4)
library(here)
library(flexdashboard)
library(shiny)
library(magrittr)
library(tidyverse)
library(forcats)
library(stringr)
library(leaflet)
library(sf)
library(rmapshaper)
library(htmltools)
library(lubridate)
library(DT)
```

```{r,eval = FALSE}

shooting_data <- read_csv(here("processed_data",
                                        "shooting_data_pre_geo_wrangled.csv"))

shooting_data_geocoded <- read_csv(here("processed_data",
                                        "shooting_data_wrangled.csv"))
```


## Creating pages

Recall that `===` is used to designate elements that are part of the naviagation bar.


We want 7 items besides the source code (which was added automatically based on the YAML code).


So first we will create 7 divisions for these main pages. We will add icons to each from [Font Awesome](https://fontawesome.com/icons?d=gallery).

Use this [link](https://fontawesome.com/icons?d=gallery) to find other icon options. If you click on the "start using this icon" botton it will take you to a page with html code like this:  

```{r, echo = FALSE, out.width="60%"}
knitr::include_graphics(here::here("img", "fontawesome.png"))
```

#### [[source]](https://fontawesome.com/icons/database?style=solid)


Only  the `fa-database` portion is requrired in the brackets after `data-icon=` to add the icon to the navigation bar.

```

About {data-icon="fa-question-circle"}
====================================

The Data {data-icon="fa-database"}
===================================== 

US Statistics {data-icon="fa-flag"}
=====================================

State Statistics {data-icon=fa-flag-checkered}
====================================

Map {data-icon="fa-map"}
====================================

Tutorial {.storyboard data-icon="fa-list-ol"}
====================================

Hotline {data-icon="fa-exclamation-triangle"}
====================================

```

## The About Page

OK, now we will start with the About page.

### Look


This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "aboutpagelook.png"))
```

### Overall Structure


Here is the overall structure for this page:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "about_page_structure.png"))
```

### Details

On this page we will have two columns - one which will be wider than the other.  Size specifications on `flexdashboard` are unitless; the width of any column included on a page is a function of the width set for a column against the sum of widths for all columns on that page. If we set columns sizes of 600 and 300 on a page with two columns, one column will be twice as large as the other column. We want the left column to be quite a bit larger than the right, so we will set the left as `70` and the right as `30`.


Thus we will start out like so:

```
About {data-icon="fa-question-circle"}
===================================== 

Column {data-width = 70}
-------------------------------------

###

Column {data-width = 30}
-------------------------------------

###

```


Recall that `###` is used to add elements to columns and rows. Note that there is no text next to the `###` syntax that designates an element of our dashboard. Previously in the examples that we showed a header was used like so `### header`:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "tab.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)

We don't actually want a header now, so we can simply use `###` without any text following it. Note that you can get away with not using the `###` but some elements will not render properly. 

Now we will add a block of text describing the dashboard to the first column and we will add an image to the second column like the following. Notice that two astrix `**` around text makes them appear as bold and one `*` makes it appear as italic. See [this RStudio cheatsheet](https://rmarkdown.rstudio.com/lesson-15.html) for some basic markdown syntax for stylizing text:

```{r, echo = FALSE}
knitr::include_graphics(here::here("img", "markdownsyntax.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/lesson-15.html)


Thus this is what the code for this page looks like (notice that there is an internal link to the `Tutrial` page:

```
About {data-icon="fa-question-circle"}
===================================== 

Column {data-width=700}
-------------------------------------

### About

**What is the purpose of this dashboard?**

This dashboard has two purposes:

1. To Illustrate trends in school shooting events in the United States
2. To demonstrate how to create a dashboard using `R`


This dashboard uses data from the open-source [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) downloaded from the [Center for Homeland Defense and Security](https://www.chds.us/c/) at the at the [Naval Postgraduate School(NPS)](https://en.wikipedia.org/wiki/Naval_Postgraduate_School). This data was downloaded in June of 2020.


Riedman, David, and Desmond O’Neill. “CHDS – K-12 School Shooting Database.” Center for Homeland Defense and Security, June 2020, [www.chds.us/ssdb](www.chds.us/ssdb).


This database includes information about school shooting events for students in grades K-12 in the United States dating back to 1970. The database has additional information not shown on our dashboard including but not limited to: 

* Location of the event at the school  
* If the event occured during a sporting event  
* Time of day of the event  
* Day of the week of the event  
* Source for the shooting information  
* If the event was pre-planned or not  
* Shooter's actions immediately following the shooting  
* Shooter characteristics (affiliation with the school, if they had accomplices, if they took hostages, and their age and race)  
* Victom characteristics (afficliation with the school, if they were targeted, their age and race)  

According to the [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/) website:

> The School Shooting Database Project is conducted as part of the [Advanced Thinking in Homeland Security (HSx)](https://www.chds.us/c/academic-programs/hsx/) program at the Naval Postgraduate School’s [Center for Homeland Defense and Security (CHDS)](Center for Homeland Defense and Security (CHDS).

> The database compiles information from more than 25 different sources including peer-reviewed studies, government reports, mainstream media, non-profits, private websites, blogs, and crowd-sourced lists that have been analyzed, filtered, deconflicted, and cross-referenced. All of the information is based on open-source information and 3rd party reporting.

> "This database was developed from open-source information and may include reporting errors."


**Want to learn how to create a dashboard just like this?**

Visit the [*Tutorial*](#tutorial) page of this dashboard to first learn the basics about building a dashboard with the `flexdashboard` package.

At the end of the tutorial we provide a link to this [supplementary resource by the Open Case Studies project](INCLUDE LINK HERE), which provides more detailed information about how ***this dashboard*** was created.

We have also included the source code (see upper right-hand corner) in this dashboard for more experienced `R` users looking to mimic some of what we did in this dashboard in their own.


**Disclaimer**

The purpose of the [Open Case Studies](https://opencasestudies.github.io){target="_blank"} project is **to demonstrate the use of various data science methods, tools, and software in the context of messy, real-world data**.

A given case study does not cover all aspects of the research process, is not claiming to be the most appropriate way to analyze a given data set, and should not be used in the context of making policy decisions without external consultation from scientific experts. 

We are simply using data from the [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/), we did not create this database. We acknowlege (like their website) that there may be reporting errors in this database. 

**License**

This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 [(CC BY-NC 3.0)](https://creativecommons.org/licenses/by-nc/3.0/us/){target="_blank"} United States License.

Column {data-width=300}
-------------------------------------

###

'''{r, echo=FALSE, fig.cap="[Photograph by Nathan Dumlao](https://unsplash.com/photos/xPHmmVKS8lM)"}
knitr::include_graphics(here::here("img", "nathan-dumlao-xPHmmVKS8lM-unsplash.jpg"))
'''
```

The image used in this second column is from a website called unsplash (https://unsplash.com/) which hosts images for free use but includes information about the photographer if you chose to credit them. A short link for this image was found by clicking on it and then clicking the share button.

Notice the `echo = FALSE` specification for the code chunk which causes the code to be evaluated but but not shown, while `fig.cap` adds the figure caption.

The image is included using the `include_graphics()` function of the `knitr` package. We need to specify where this image is located for this to work. You can do this without specifying a path if the image file is in the same directory as your .Rmd file that you are using to create your dashboard. However using the `here()` function of the `here` package we can oranize our files a bit. This function will automatically start the path wherever we have included an RStudio project file, this can be done in RStudio like so:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "project.png"))
```
If you are new to using RStudio projects, please see this [link](https://r4ds.had.co.nz/workflow-projects.html) for more information.

Then if we create a directory or folder called `img` and place our image files in this directory, then we can specify the full path to this file on our computer, by just using `here::here("img", "name_of_image.png")`. The `include_graphics()` function works for a variety image file types. 

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "newdir.png"))
```


## The Data Page (Interactive)

Now Let's create a page about the data that we are using.

### Look


This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "The_Data_Page.png"))
```

### Overall Structure
Here is the overall structure for this page:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "Data_page_structure.png"))
```

### Details


To create the structure for this page that will display the data, we will have two columns, with the first one (on the left) wider than the other. Again we will have a block of text in the column on the left like so:

```
The Data {data-icon="fa-database"}
===================================== 


Column {data-width=70}
-------------------------------------

###

The data is from the [Center for Homeland Defense and Security (CHDS)](Center for Homeland Defense and Security (CHDS) [K-12 Shool Shooting Database](https://www.chds.us/ssdb/dataset/). Methods are outlined [here](https://www.chds.us/ssdb/methods/) as to how incidents were identified and authenticated.

According to their website: 
> "This database was developed from open-source information and may include reporting errors."



Column {data-width=30}
-------------------------------------

###

```



Now we will add our `DT_table` to the first column. First we need to include the code that we previously used to create the `DT_table` in our dashboard .Rmd file:


```{r}
DT_table <- shooting_data%>%
  dplyr::select(Date,
                School,
                City,
                State,
                `Killed (includes shooter)`,
                `Narrative (Detailed Summary/ Background)`) %>%
  rename("Deaths" = `Killed (includes shooter)`) %>%
  rename("Narrative" = `Narrative (Detailed Summary/ Background)`)
```


We then include some code to render this interactive table in our dashboard. Since we have `shiny` enabled in our YAML header, we can use the `renderDataTable()` of the `DT` package to produce the output we desire. We also want to use the `options` argument to specify how the data is rendered. The `scroller = TRUE` argument adds a scroll bar to the table, the scrollY argument specifies that the scroll bar should be for they Y axis direction (up and down) of the table and specifies how large the scroller should be, the `pageLength` argument specifies how many rows should be displayed simultaneously within the table, and the `autoWidth = TRUE` argument specifies that the table should fit the space of the column or page it is within. We will also add a caption with a link to the original data using the `tags()` and `withTags()` functions of the `htmltools` package. Different options for types of tags can be selected using the `$`.


```{r, echo = FALSE, out.width="60%"}
knitr::include_graphics(here::here("img", "tags.png"))
```

```{r, eval=FALSE}
DT::renderDataTable({
  DT::datatable(DT_table,
                caption = htmltools::tags$caption(
                  style = 'caption-side: top; text-align: Left;',
                  htmltools::withTags(
                    div(HTML('<a href="https://www.chds.us/ssdb/dataset/)">Click here to be redirected to a page where this data can be downloaded.</a>')))),
                options = list(autoWidth = TRUE,
                               pageLength = 10,
                               scroller = TRUE,
                               scrollY = '450px'))
})
```


We will also add another image to the column on the right, overall the code looks like this:


```
Column {data-width=70}
-------------------------------------

###

The data used in this dashboard is from the [**Center for Homeland Defense and Security (CHDS)**](Center for Homeland Defense and Security (CHDS)) [**K-12 Shool Shooting Database**](https://www.chds.us/ssdb/dataset/). 

Their methods for identifying and authenticating incidents are outlined [here](https://www.chds.us/ssdb/methods/).

According to their website: 

>*"This database was developed from open-source information and may include reporting errors."*

***



'''{r, echo=FALSE}
# Create the DT table first
DT_table <- shooting_data %>%
  dplyr::select(Date,
                School,
                City,
                State,
                `Killed (includes shooter)`,
                `Narrative (Detailed Summary/ Background)`) %>%
  rename("Deaths" = `Killed (includes shooter)`) %>%
  rename("Narrative" = `Narrative (Detailed Summary/ Background)`)
'''



'''{r, echo=FALSE}
DT::renderDataTable({
  DT::datatable(DT_table,
                caption = htmltools::tags$caption(
                  style = 'caption-side: top; text-align: Left;',
                  htmltools::withTags(
                    div(HTML('<a href="https://www.chds.us/ssdb/dataset/)">Click here to be redirected to a page where this data can be downloaded.</a>')))),
                options = list(autoWidth = TRUE,
                               pageLength = 10,
                               scroller = TRUE,
                               scrollY = '450px'))
})
'''

Column {data-width=30}
-------------------------------------

###

'''{r, echo=FALSE, fig.cap="[Photograph by Rubén Rodriguez](https://unsplash.com/photos/IXTvnOOSTyU)"}
knitr::include_graphics(here::here("img", "ruben-rodriguez-IXTvnOOSTyU-unsplash.jpg"))
'''
```



## The US Statistics Page

Now Let's create a page for **US Statistics** we would like to share. 

### Look
This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "US_Statistics_page.png"))
```

### Overall Structure
Here is the overall structure for this page:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "US_stats_page_overview.png"))
```

### Details

This time we will use  the `.tabset` and `.tabset-fade` options specified for our first column. 

```
US Statistics {data-icon="fa-flag"}
===================================== 


Column {data-width=70 .tabset .tabset-fade}
-------------------------------------
```

After having specified the `.tabset` and `.tabset-fade` options, we can create new tabs in the same way we would add elements to our dashboard with the `###` syntax. Just like in this example:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "tab.png"))
```

##### [[source]](https://rmarkdown.rstudio.com/flexdashboard/layouts.html)


Let's make a tab for yearly shooting events and deaths, a tab for cumulative shooting events and deaths, and a tab about the number of deaths per shooting. In each tab we will include the code for the plots that we have previously created. 

```

US Statistics {data-icon="fa-flag"}
===================================== 

Column {data-width=700 .tabset .tabset-fade}
-------------------------------------

### Yearly Deaths and Shootings

'''{r}

start <- 1970
end <- 2020

shootings_per_year<- shooting_data %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()

deaths_per_year<-shooting_data %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))


per_year<-full_join(shootings_per_year, deaths_per_year)
per_year %<>%pivot_longer( cols = (-Date_year), 
                           values_to = "events", 
                           names_to = "id")

per_year%<>% 
  mutate(id = forcats::fct_inorder(id))

per_year %>%
    ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_grid(~id)+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
   labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = "United States",
         y = "Number of events",
         x = "Year")+
  scale_fill_manual(values = c("black", "black"))+
  theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background =element_rect(fill="cornflowerblue"),
      strip.text = element_text(colour = 'white', face = "bold", size = 14))
'''
 
 

### Yearly Cumulative Deaths and Shootings

'''{r}

shootings_per_year_cum <- shootings_per_year %>%
    mutate(Shootings = cumsum(Shootings))

deaths_per_year_cum <- deaths_per_year %>%
    mutate(Deaths= cumsum(Deaths))


per_year_cum <- full_join(shootings_per_year_cum, deaths_per_year_cum)


per_year_cum %<>%pivot_longer( cols = c(Shootings,
                                        Deaths ), 
                           values_to = "events", 
                           names_to = "id")
per_year_cum%<>% 
  mutate(id = forcats::fct_inorder(id))

per_year_cum %>%
ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_grid(~id)+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    scale_fill_manual(values = c("black", "black"))+
    theme_minimal() +
    labs(title = "Cumulative Yearly Shootings and Deaths\nAttributable to School Shootings",
         subtitle = "United States",
         y = "Cumulative number of events",
         x = "Year") +
    theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background = element_rect(fill="cornflowerblue"),
        strip.text = element_text(colour = 'white', face = "bold", size = 14))
'''

### Deaths Per Shooting

'''{r}
deaths_perc_event <-shooting_data %>%
   count(`Killed (includes shooter)`) %>%
   rename("num_events"= n) %>%
   mutate(percent = round(num_events/sum(num_events)*100, digits =1))

greater_than4<-deaths_perc_event %>% 
  filter(`Killed (includes shooter)` >= 4) %>% 
  colSums()

deaths_perc_event %<>%  bind_rows(greater_than4)

deaths_perc_event %<>% mutate(category = paste0(`Killed (includes shooter)`, " deaths ", "\n(", percent, "%)")) 
deaths_perc_event %<>% 
  mutate(category = case_when(
    category ==  last(pull(deaths_perc_event, category)) ~ paste0("4+ deaths ", "\n(", percent, "%)"),
    category == "1 deaths" ~ "1 death",
    TRUE ~ category))

deaths_perc_event %>% select(-`Killed (includes shooter)`) %>%
  filter(str_detect(category, "0 deaths|1 death|2 deaths|3 deaths|4+")) %>%
  mutate(percent = round(percent)) %>%
  select(-num_events) %>%
  tidyr::pivot_wider(names_from = category, 
                    values_from = percent) %>%
  waffle::waffle(legend_pos = "bottom", title = "Deaths Per School Shooting", 
       xlab="1 square ~ 1%")+  scale_fill_viridis_d()

'''
```

In the second column we will include what are called value boxes to contain statistics that will remain static as the user moves through the tabs of the first column

```
Column {data-width=30}
------------------------------------- 
```

We want to display some important statistics, such as:

+ Total number of people wounded in a school shooting   
+ Total number of deaths from a school shooting  
+ Median number of shots fired  
+ Percentage of shootings where the shooter was the only victom  
+ Percentage of shootings where a single handgun was used  
+ Percentage of shootings where the shooter was male

To create a value box we will use the `valueBox()` function of the `flexdashboard` package. The text for the the value box is specified by the text following the `###` syntax.

There are a few arguments to be aware of for this function:

1) value - this is the value to be displayed in the box - this usually a number, but might be text
2) caption - if desired, you can add text to be displayed under the value but keep in mind that you will also include text with the `###` syntax
3) icon - if you would like to add an icon you can specify it like so: `icon = fa-flag`
4) color - this changes the color of the box
5) href - if you would like to add a URL link you can do so with this argument

Thus we can create a value box for the total number of people wounded as follows, where we use the base `sum()` function to calculate the sum of all the values for the `Wounded` variable which was extracted using the `pull()` function of the `dplyr` package. We need to remove `NA` values to be able to calculate the sum and we can do this using the `na.rm = TRUE` argument. 

```
### **Total Wounded**
    
'''{r}
valueBox(value = sum(pull(shooting_data, Wounded), na.rm = TRUE),
         color = "white")
'''
```

Then we do the same for the total number of deaths:

```
    
### **Total Deaths**

'''{r}
valueBox(value = sum(pull(
  shooting_data,`Killed (includes shooter)`), na.rm = TRUE),
         color = "white")
'''
```

To calculate the median number of shots fired we can use the  `median()` function of the `stats` package which is loaded automatically like the `base` functions in an instance of R. We will also use the base `round()` function to round the number to have 2 places after the decimal.

```
### **Median Shots Fired**

'''{r}
valueBox(value = round(median(
  pull(shooting_data,
      `Number of Shots Fired`), na.rm = TRUE), 2),
  color = "white")
'''
```
To calculate the percentage of shootings where the shooter was the only victom, we calcluate the sum of shootings where the shooter was the only victom and divide this by the sum of the total number of shootings that involved at least one death. The `paste0` function is used to add the percentage symbol.

```
### **Shooter Was Only Victim**

'''{r}

suicide <- sum(pull(shooting_data,`Suicide (Shooter was only victim) Y/N/ N/A`),
               na.rm = TRUE)/ sum(pull(shooting_data,`Killed (includes shooter)`)>0, na.rm = TRUE)
suicide <- round(suicide*100, 1)

valueBox(value = paste0(suicide,"%"), 
         color = "white")
'''
```

For this value box the percentage of shootings where a single handgun was used was calcuated by using the `case_when()` function to specify all cases where the `Firearm Type` variable was equal to `"Handgun"` as `TRUE` and all others as `FALSE`. This allows us to use the base `sum()` function as `TRUE` values will be counted as a value of `1` and `FALSE` values will be counted as a value of `0`. This sum was then divided by the total number of shooting events by getting the length of the `Firearm Type` variable using the base `length()` function. The next value box about the gender of the shooter was calculated in a similar manner. 

```
### **Use of a Single Handgun**

'''{r}

valueBox(value = 
  paste(as.character(round(100 *(sum(case_when(
      pull(shooting_data,`Firearm Type`) == "Handgun" ~ TRUE,
                                                 TRUE ~ FALSE), na.rm = TRUE)
    /
      length(pull(shooting_data,`Firearm Type`))),
    1)), "%"),
  color = "white")
''' 

### **Shooter Was Male**

'''{r}
valueBox(value =
  paste(as.character(round(100 * (sum(
    case_when(pull(shooting_data,`Shooter Gender`) == "Male" ~ TRUE,
                                                        TRUE ~ FALSE),
                                      na.rm = TRUE)
    /
      length(shooting_data$`Shooter Gender`)),
    1)), "%"),
  color = "white")
'''
```





## The State Statistics Page (Interactive)

Now Let's create a page for **State Statistics** we would like to share. 

### Look


This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "State_Statistics_page.png"))
```

### Overall Structure


Here is the overall structure for this page:

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "states_stats_page_overview.png"))
```

### Details


On this page we want the user to be able to select data for a specific state and render plots and get statistics just for the selected state. To do this we will utalize the `renderPlot()` and `renderValueBox()` functions of the `flexdashboard` package, as well as the `selectInput()` function of the `shiny` package. See this [website](https://rmarkdown.rstudio.com/flexdashboard/shiny.html) for more information on using `shiny` to create interactive dashboards with `flexdashboard`.


The first thing we need to do to allow this page to be interactive is to add `runtime: shiny` to the YAML header at the top of the R Markdown file.

The next thing we want to do is add the `{.sidebar}` attribute to the first column of this page. This allows us to use `shiny` input functions in this column.

Then we will use the `selectInput()` function to create a menu for the user to interact with and add it to this column.

Finally we will use the `renderPlot()` function  and `renderValueBox()` function to use the input from the user to render plots and value boxes based on their input.

The `selectInput()` function allows us to provide the user with a pull down menu of options for states. The main arguments for this function are:
1) inputId - this is what the selection will be called in subsequent code
2) label - this is what the user sees above the pull down menu
3) choices - this is a list of options for the menu
4) selected - this causes a particular option to be the default choice

This is placed in a column on the far left side that is more narrow than the others. 

```
State Statistics {data-icon=fa-flag-checkered}
===================================== 

Column {.sidebar data-width=250}
-----------------------------------------------------------------------

Note that the statistics shown do not account for other possibly influential state specific features like population density or gun laws among others.


'''{r}
selectInput(inputId = "state_selected", 
              label = "Select a state to explore:",
            choices = unique(shooting_data%>%
                             filter(!is.na(State)) %>%
                             pull(State)), selected = "Maryland")

#  Washington, D.C. gets excluded by this
'''
```

In the next column we will have our plots like we did on the last page, thus again we will use tabset. However, the difference here is that we need to include the `renderPlot()` function around all of our code for each plot and we need to use the data that the user selected. This will automatically be in a data object called `input` and it will be within a variable called `state_selected"` based on what we used for the `inputID` in the `select_Input()` function.


```
Column {data-width=750 .tabset .tabset-fade}
-----------------------------------------------------------------------

### Yearly Deaths and Shootings

'''{r}

renderPlot({

shooting_data_state <- shooting_data[shooting_data$State == input$state_selected, ]

shootings_per_year<- shooting_data_state  %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()

deaths_per_year<-shooting_data_state  %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))


per_year<-full_join(shootings_per_year, deaths_per_year)
per_year %<>%pivot_longer( cols = (-Date_year), 
                           values_to = "events", 
                           names_to = "id")

per_year%<>% 
  mutate(id = forcats::fct_inorder(id))

per_year %<>%
    ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_grid(~id)+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
   labs(title = "Yearly Shootings and Deaths Attributable to School Shootings",
         subtitle = input$state_selected,
         y = "Number of events",
         x = "Year")+
  scale_fill_manual(values = c("black", "black"))+
  theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background =element_rect(fill="cornflowerblue"),
      strip.text = element_text(colour = 'white', face = "bold", size = 14))

})
'''
 
 

### Yearly Cumulative Deaths and Shootings

'''{r}

renderPlot({

shooting_data_state <- shooting_data[shooting_data$State == input$state_selected, ]

shootings_per_year<- shooting_data_state  %>%
    group_by(Date_year) %>%
    count() %>%
  rename("Shootings" = n) %>%
    ungroup()

shootings_per_year_cum <- shootings_per_year %>%
    mutate(Shootings = cumsum(Shootings))

deaths_per_year<-shooting_data_state  %>% 
  group_by(Date_year) %>%
  summarize(Deaths =sum(`Killed (includes shooter)`))


deaths_per_year_cum <- deaths_per_year %>%
    mutate(Deaths= cumsum(Deaths))


per_year_cum <- full_join(shootings_per_year_cum, deaths_per_year_cum)


per_year_cum %<>%pivot_longer( cols = c(Shootings,
                                        Deaths ), 
                           values_to = "events", 
                           names_to = "id")
per_year_cum%<>% 
  mutate(id = forcats::fct_inorder(id))

per_year_cum %>%
ggplot(aes(x = Date_year, y = events, fill =id)) +
    geom_col()+
    facet_grid(~id)+
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    scale_fill_manual(values = c("black", "black"))+
    theme_minimal() +
    labs(title = "Cumulative Yearly Shootings and Deaths\nAttributable to School Shootings",
         subtitle = input$state_selected,
         y = "Cumulative number of events",
         x = "Year") +
    theme(legend.position = "none", 
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 90),
        strip.background = element_rect(fill="cornflowerblue"),
        strip.text = element_text(colour = 'white', face = "bold", size = 14))

})

'''

### Deaths Per Shooting

'''{r}

renderPlot({

shooting_data_state <- shooting_data[shooting_data$State == input$state_selected, ]
library(tidyr)
deaths_perc_event <-shooting_data_state %>%
   count(`Killed (includes shooter)`) %>%
   rename("num_events"= n) %>%
     tidyr::drop_na() %>%
   mutate(percent = round(num_events/sum(num_events)*100, digits =1))


greater_than4<-deaths_perc_event %>% 
  filter(`Killed (includes shooter)` >= 4) %>% 
  colSums()

deaths_perc_event %<>%  bind_rows(greater_than4)

deaths_perc_event %<>% mutate(category = paste0(`Killed (includes shooter)`, " deaths ", "\n(", percent, "%)")) 
deaths_perc_event %<>% 
  mutate(category = case_when(
    category ==  last(pull(deaths_perc_event, category)) ~ paste0("4+ deaths ", "\n(", percent, "%)"),
    category == "1 deaths" ~ "1 death",
    TRUE ~ category))

deaths_perc_event %<>%filter (!duplicated(category))

deaths_perc_event %>% select(-`Killed (includes shooter)`) %>%
  filter(str_detect(category, "0 deaths|1 death|2 deaths|3 deaths|4+")) %>%
  mutate(percent = round(percent)) %>%
  select(-num_events) %>%
  tidyr::pivot_wider(names_from = category, 
                    values_from = percent) %>%
  waffle::waffle(legend_pos = "bottom", title = "Deaths Per School Shooting", 
       xlab="1 square ~ 1%")+  scale_fill_viridis_d()

})

'''

Column {data-width=300}
------------------------------------- 

### **Total Deaths**

'''{r}
renderValueBox({
shooting_data_state <- shooting_data[shooting_data$State == input$state_selected, ]

valueBox(sum(pull(shooting_data_state,`Killed (includes shooter)`), na.rm = TRUE),
         color = "white")
})
'''

### **US State Average Death Count**
'''{r}

shooting_data_state <-shooting_data %>% 
  group_by(State_abb, State) %>%
    count(na.rm = TRUE) %>%
  rename(shootings = n) %>%
  ungroup() %>%
mutate(state_sum = sum(shootings)) %>%
  mutate(state_avg = state_sum/50) %>%
  mutate(shooting_rank = rank(-shootings))

state_data <- poliscidata::states
state_data %<>%
  select(stateid, pop2010) %>%
  mutate(poprank = rank(-pop2010)) %>%
  mutate(stateid = as.character(stateid))%>%
  mutate(stateid = str_remove_all(stateid, pattern = " "))

shooting_data_state<-full_join(shooting_data_state, state_data, by = c("State_abb" = "stateid"))

deaths_State <-shooting_data %>% 
  group_by(State) %>%
 summarise(wounded = sum(Wounded, na.rm = TRUE),
            deaths = sum(`Killed (includes shooter)`, na.rm = TRUE))%>%
  mutate(wounded_rank = rank(-wounded),
         death_rank = rank(-deaths)) %>%
  drop_na()

state_data <-left_join(shooting_data_state, deaths_State)

USavg<- mean(pull(state_data, deaths), na.rm = TRUE)
valueBox(USavg,
         color = "white")

'''

### **State Death Rank (1 is highest)**

'''{r}
renderValueBox({
shooting_data_state<- state_data[state_data$State == input$state_selected, ]
shooting_data_state %<>%drop_na()

valueBox(pull(shooting_data_state, death_rank),
         color = "white")
})
'''

### **State Population Rank (1 is highest)**

'''{r}
renderValueBox({
shooting_data_state <- state_data[state_data$State == input$state_selected, ]
shooting_data_state %<>%drop_na()

valueBox(pull(shooting_data_state, poprank),
         color = "white")
})
'''


### **State Death Rank vs. Expectation Based Only on Population Rank **
'''{r}
renderValueBox({
shooting_data_state <- state_data[state_data$State == input$state_selected, ]
shooting_data_state %<>%drop_na()

difference <-pull(shooting_data_state, death_rank) - pull(shooting_data_state, poprank)
valueBox(case_when(difference > 0 ~ "Lower than expected",
                   difference < 0 ~ "Higher than expected",
                   TRUE ~ "As expected"), 
color = ifelse(difference< 0,  "coral", "lightgreen"))
})
'''


```


```
State Statistics {data-icon=fa-flag-checkered}
===================================== 

Column {.sidebar data-width=250}
-----------------------------------------------------------------------

'''{r}
selectInput("state_selected", label = "Select a state to explore:",
            choices = unique(map_data("state") %>%
                               filter(region!="district of columbia") %>%
                               pull(region)) %>%
              str_to_title(), selected = "Maryland")
'''

Column {data-width=750 .tabset .tabset-fade}
-----------------------------------------------------------------------

### Yearly Deaths

'''{r}
renderPlot({
  start <- 1970
  end <- 2020
  state_df <- as_tibble(cbind(state.abb, state.name))
  shooting_data_geocoded <- shooting_data_geocoded %>%
    rename("State_abb" = State) %>%
    left_join(state_df, by = c("State_abb" = "state.abb")) %>%
    rename("State" = state.name) %>%
    mutate(State = str_to_title(tolower(State))) %>%
    mutate(Date = as.Date(Date, format = "%m/%d/%Y")) # this must be applied to wrangling
  shooting_data_geocoded_f <- shooting_data_geocoded[shooting_data_geocoded$State == input$state_selected, ]
  shooting_data_geocoded_f <- shooting_data_geocoded_f %>%
    mutate(Date_year = year(Date)) %>%
    group_by(Date_year) %>%
    count() %>%
    ungroup()
  shooting_data_geocoded_f %>%
    ggplot(aes(x = Date_year, y = n)) +
    geom_bar(stat = "identity", fill = "black") +
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
    labs(title = "Statewide School Shootings",
         subtitle = input$state_selected,
         x = "Yearly Deaths Attributable to School Shootings",
         y = "")
})
'''

### Yearly Cumulative Deaths

'''{r}
renderPlot({
  start <- 1970
  end <- 2020
  state_df2 <- as_tibble(cbind(state.abb, state.name))
  shooting_data_geocoded2 <- shooting_data_geocoded %>%
    rename("State_abb" = State) %>%
    left_join(state_df2, by = c("State_abb" = "state.abb")) %>%
    rename("State" = state.name) %>%
    mutate(State = str_to_title(tolower(State))) %>%
    mutate(Date = as.Date(Date, format = "%m/%d/%Y")) # this must be applied to wrangling
  shooting_data_geocoded_f2 <- shooting_data_geocoded2[shooting_data_geocoded2$State == input$state_selected, ]
  shooting_data_geocoded_f2 <- shooting_data_geocoded_f2 %>%
    mutate(Date_year = year(Date)) %>%
    group_by(Date_year) %>%
    summarize(N = n()) %>%
    ungroup() %>%
    complete(Date_year = seq(start, end, by=1),
             fill = list(N = 0)) %>%
    mutate(n_cumsum = cumsum(N))
  shooting_data_geocoded_f2 %>%
    ggplot(aes(x = Date_year, y = n_cumsum)) +
    geom_bar(stat = "identity", fill = "black") +
    scale_x_continuous(breaks = seq(start, end, by = 5),
                 labels = seq(start, end, by = 5),
                 limits = c(start-1, end+1)) +
    theme_minimal() +
    labs(title = "Yearly Cumulative Deaths Attributable to School Shootings",
         subtitle = input$state_selected,
         x = "School Shootings",
         y = "")
})
'''

### Deaths per Shooting

'''{r}
renderPlot({
  state_df3 <- as_tibble(cbind(state.abb, state.name))
  shooting_data_geocoded3 <- shooting_data_geocoded %>%
    rename("State_abb" = State) %>%
    left_join(state_df3, by = c("State_abb" = "state.abb")) %>%
    rename("State" = state.name) %>%
    mutate(State = str_to_title(tolower(State)))
  shooting_data_geocoded3 <- shooting_data_geocoded3 %>%
    mutate(Date = as.Date(Date, format = "%m/%d/%Y")) %>%
    mutate(Date_year = year(Date)) %>%
    group_by(State,`Killed (includes shooter)`) %>%
    summarize(N = n())
  shooting_data_geocoded_f3 <- shooting_data_geocoded3[shooting_data_geocoded3$State == input$state_selected, ]
  shooting_data_geocoded_f3 %>%
    ggplot(aes(x = `Killed (includes shooter)`, y = N)) +
    geom_bar(stat = "identity", fill = "black") +
  scale_x_continuous(breaks = seq(0,30, by = 1),
                     labels = seq(0,30, by = 1),
                     limits = c(-1,30)) +
  scale_y_continuous() +
    theme_minimal() +
    labs(title = "Deaths per School Shooting",
         subtitle = input$state_selected,
         x = "School Shootings",
         y = "")
})
'''
```


##  The Map page (Interactive)

Ok now we are ready to create our map page. Previously, in the  [**Data Exploration and Wrangling**] section, we geocoded our data and modified the `latitude` and `longitude` variables so that events that occured in the same location would have slightly different values so that they will not cover one another in our map.

To create our map we will use the `leaflet` package which uses the [Leaflet](https://leafletjs.com/)  JavaScript library. 

### Leaflet

`Leaflet` works by provided by adding base data (such as a map) and then adding markers if desired in layers. This is very similar to how `ggplot2` functions (pun intended).

The layers displayed can be controlled using a sort of legend. Depending on the type of layers, some information may be displayed mutually exclusive of the other layers; other layers (such as circles/general markers) can be toggled on and off. 

Clustering options can also be applied to circles/markers. Some examples of this can be found on the bottom of [this website](https://rstudio.github.io/leaflet/markers.html).

The `groups` in leaflet can be thought of as layer-specific IDs that create labels for legends and allow specific layers to be referred to in separate functions. 

Thus, if we called a group "Layer 1" and then in a subsequent layer refer to "Layer 1", `Leaflet` will correctly identify which layer is being referenced.

Note that `leaflet` can require a lot of computational power depending on the types of maps produced.


### Look


This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "The_Map_Page.png"))
```

### Overall Structure


The overall structure for this page is simple. There is just one column which will contain the map.

```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics(here::here("img" , "map_page_structure.png"))
```

### Details

First we create a smaller dataset that just includes the data that we want to use in the map. We will include the date, the name of the school and the narrative for each point as a [popup](https://rstudio.github.io/leaflet/popups.html) that will be shown when the user hovers over a point. 

We need to do this using [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML) code as the `leaflet` package will ultimately render the map using this language.

First we will use the paste function to combine these elements as well as HTML code to create line breaks and bold the name of the school.

To create line breaks in HTML, the `<br>` syntax is used. Thus this is used to separate each part of the elements that are getting pasted together with the base `paste()` function by being specified as the separator with the `sep` argument.

To create bold font in HTML, the text is surrounded by `<b>` and `</b>` like so: `<b> Bold text </b>`. Thus only the school name is in bold.

Finally the `<div>` and `</div>` are content dividers in html. Thus they separate the individual shooting event information sections that will be plotted on the map. The first divider can also take information about the style of the output. This uses [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) code, which is what is used to stylize HTML.  The code here states that the height of the text box for each event should have a height that is proportional to the text, that the [height of each line](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height) should be of 1 [em units](https://www.w3.org/Style/Examples/007/units.en.html) (which stands for element - thus 1 unit relative to the size of the element - therefore gaps between lines are the same height as the lines of text), the `overflow:visible` code specifies what to do in case the text box text is too large - in this case users can scroll (see [here](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow) for more options), and the [padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding) specification sets the size of the margins of the text box around the text.  

See this [website](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div) to learn more about HTML code.

```
Map {data-icon="fa-map"}
===================================== 
Column
------------------------------------- 
    
### 

This map shows where school shootings took place in the United States between January 1970 to June 2020 according to the the open-source [Center for Homeland Defense and Security](https://www.chds.us/c/) (CHDS) [K-12 School Shooting Database](https://www.chds.us/ssdb/dataset/). 
    
'''{r}
shooting_information0 <- paste('<div style="height:auto;line-height:1em;overflow:scroll;padding:1em">',
                              shooting_data_geocoded$Date,
                              "<b>",
                              shooting_data_geocoded$School,
                              "</b>",
                              shooting_data_geocoded$`Narrative (Detailed Summary/ Background)`,
                              "</div>",
                              sep = "<br>")


'''
```

The next bit of code then uses this data and the `shooting_data_geocded` to actually create the map!

The `leaflet()` function of the `leaflet` package creates a Leaflet map [widget](https://en.wikipedia.org/wiki/Web_widget) using the  [`htmlwidgets`](https://cran.r-project.org/web/packages/htmlwidgets/index.html) package, which allows the map to be rendered as an application within HTML websites.

This first line of code starts the process of making the widget, but just like the `ggplot()` function of `ggplot2` it creates an empty map and layers need to be added.

The `addProviderTiles()` function of the `leaflet()` package does just that, by adding the map background. We will add three different kinds of map backgrounds. See [here](http://leaflet-extras.github.io/leaflet-providers/preview/index.html) for all the options of providers which create a variety of distinct backgrounds and then the `group` argument names each of these layers to be refered to later. The last layer added will be the one shown by default.

OK, at this point we still only have a map in general. Now we need to add the data about shooting events. 

To do this we will add markers to the plot using the `addCircleMarkers()` function. This function takes many different arguments. See details about them [here](https://cran.r-project.org/web/packages/leaflet/leaflet.pdf). 

Importantly, we need to specify what variables in our provided data `shooting_data_geocoded` contains the longitude values (`lng`) and the latitude values (`lat`). 

We will also use the following arguments:  
+ The`radius` argument specifies how large the circles for the points will be  
+ The `color` argument specifies the color of the individual points  
+ The `fillOpacity` argument allows for the filling of the points to a bit translucent if set below 1  
+ Importantly the `clusterOptions` argument can be used to cluster points together into larger cirlces  
+ The `group` argument specifies what the points should be called in the legend and what this layer should be refered to as for later use  


We will also add a minimap using the `addMiniMap()` function which can be useful to see where you are on the map. The type of plot style to use for the minimap is specfied with the `tiles` argument and the `toggleDisplay` argument allows for the user to remove this feature.

Importantly, the `addLayersControl()` function  allows users to toggle between different backgrounds and markers. In our case we have three different background layers which are referred to as `baseGroups` and we have one `overlayGroups` which is our circle markers for shooting events. The group names for these need to be identified to allow users to toggle between them. 


The `set_view()` function allows for the starting position and zoom to be modified. This allows us to center the map around the continental US.

```
'''{r}
leaflet(shooting_data_geocoded) %>%
  addProviderTiles(provider = providers$OpenStreetMap, group = "OpenStreetMap") %>%
  addProviderTiles(provider = providers$Esri.WorldImagery, group = "ESRI World Imagery") %>%
  addProviderTiles(provider = providers$Stamen.TonerLite, group = "Toner")%>%
  addCircleMarkers(popup = ~shooting_information0,
                     lng = ~longitude,
                     lat = ~latitude,
     radius = 5,
     color = "red",
     fillOpacity = 0.2,
     clusterOptions = markerClusterOptions(),
     group = "Circles") %>%
  addMiniMap(tiles = providers$Stamen.Toner,
              toggleDisplay = TRUE) %>%
  addLayersControl(
     baseGroups = c("Toner Lite",
                    "OpenStreetMap",
                    "ESRI World Imagery"),
     overlayGroups = c("Circles")) %>%
   setView(lng = -98.35, lat = 39.5, zoom = 4)
'''
```

Now we only have one finaly page. 

## The Tutorial Page

Now we will create a **Tutorial** page that links to this case study. This will provide a simple overview of how we created the dashboard. 

### Look

This is what the page will look like:

```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "the_Tutorial_Page.png"))
```


### Overall Structure

To create this page we will use a sepecial layout called a [storyboard](https://en.wikipedia.org/wiki/Storyboard). Story boards are used in many other fields but the idea is that there are multiple images in a sequence. To create our storyboard page with `flexdashboard` we will use `{.stroyboard}` next to the page name. Then each page name will be specified using this syntax: `###`. 

Here you can see the top part of the overall structure:
```{r, echo=FALSE}
knitr::include_graphics(here::here("img" , "tutorialStructure.png"))
```

### Details
 The code for this page is fairly straightforward. 
 
 <details> <summary> Click here if you would like to see it. </summary>

```
Tutorial {.storyboard data-icon="fa-list-ol"}
=========================================   

### **1)** Load the `flexdashboard` package.

Install the package if you don't have the package installed already

'''{r, echo=TRUE, eval=FALSE}
install.packages("flexdashboard")
install.packages("shiny")
'''

Once installed, the package is ready to be loaded into the `R` environment.

'''{r, echo=TRUE}
library(flexdashboard)
library(shiny)
'''

This all needs to be done separately in the `R` console.

### **2)** Create an `RMD` document.   

Dashboards can be created with `flexdashboard` in the `HTML` format. 

`flexdashboard` uses `RMarkdown` to produce dashboards that can contain `R` output.

This makes it possible to include several mediums in our dashboard such as plots created with `ggplot` or maps created with `leaflet`.
    
### **3)** Create an appropriate `YAML`.

The use of `flexdashboard` alters the way `RMarkdown` documents function. These altered functions are largely dependent on the metadata we use to produce the dashboard. Metadata for the dashboard can be configured in the `YAML` of the `RMD`. 

An `HTML` document created with `RMarkdown` includes a `YAML` that is some variation of this:

'''
---
title: "Untitled"
author: "Michael Ontiveros"
date: "8/12/2020"
output: html_document
---
'''

We used the following `YAML` for this dashboard:

'''
output: 
  flexdashboard::flex_dashboard:
    logo: https://icons.iconarchive.com/icons/icons8/windows-8/48/Programming-Dashboard-icon.png
    theme: readable
    orientation: columns
    source: embed
    vertical_layout: fill
runtime: shiny
'''

We introduce an icon, provide a theme with a color scheme, define the orientation (and thus order) of coded output, include the code used, limit scrolling, and allow `shiny` widgets to be used.

### **4)** Design the layout of the dashboard.

Dashboards are inherently visual, making this step the most time intensive after content creation. We need to present the data in a way that is both meaning and visually appealing.

On this dashboard, we wanted to present static plots of the United States and of individual states. We also wanted to display the locations of school shootings and provide some information about school shootings. Aside from being a dashboard, we wanted to create an educational resource that was reproducible for others. Lastly, as a sensitive topic, we wanted to raise awareness and provide information that could help others act.

Given these goals, we decided on the following page layout:

+ The Data
+ US Statistics
+ State Statistics
+ Map
+ About
+ Tutorial
+ Hotline
+ Source Code

This layout ensured that we did to not include too many components.

The first page gives users to the opportunity to look at the data themselves. More complicated components such as the map of each incident were left alone on a single page. US and state-level statistics were separated from one another. This short tutorial on how to create the dashboard and source code were included in the dashboard with programmers at all levels in mind. The goals of the dashboard and actionable information were each given separate pages from the output. 

For your dashboard, this may take as long as the output you would like to share took you to produce. 

### **5)** Add content to the dashboard.

You can begin adding content to the dashboard once you have an initial layout in mind. Keep in mind that this will likely be an iterative process. 

The `RMarkdown` file used to create a dashboard with `flexdashboard` works similarly to any other `RMarkdown`. There are some exceptions.

'''{r, echo = TRUE}
# This output was created with chunk options: {r, echo = TRUE}
paste("Code chunks can be explicitly included")
'''

'''{r}
# This output was created with chunk options: {r}
paste("Code chunks are hidden by default")
'''

Pages and columns within pages can be defined.

'''
Page
=========================================   

Column {data-width=500}
-------------------------------------

Column {data-width=500}
-------------------------------------
'''

As mentioned before, the `flexdashboard` metadata included in the `YAML` does also alter how `RMarkdown` functions. For more on how you can leverage both `RMarkdown` and `flexdashboard` to produce a dashboard, click [here](https://rmarkdown.rstudio.com/flexdashboard/index.html).

This [supplementary resource by the Open Case Studies project](INCLUDE LINK HERE) provides a case study on how to create this very dashboard in more detail.
```

</details>


## The Hotline page

Lastly, we will create a **Hotline** page to spread awareness.

```
Hotline {data-icon="fa-exclamation-triangle"}
=========================================   

Column {data-width=600}
-------------------------------------

###

**Warning Signs**

From [Sandy Hook Promise](https://www.sandyhookpromise.org/gun-violence/know-the-signs-of-gun-violence/)...

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Here is a list of potential warning signs that can signal an individual may be in crisis and/or need help:

+ Suddenly withdrawing from people and activities
+ Consistent bullying or intimidating others, or being bullied by others
+ Extreme mood or personality changes
+ Victim of constant social rejection
+ Talking about plans or actively making plans to harm themselves or others
+ Bringing a weapon to school – or threatening or talking about doing so
+ Bragging about or warning others about an upcoming act of violence
+ Recruiting others to join in a planned act of violence
+ Warning students to stay away from school or events
+ Expressing fascination with guns and/or school shootings
+ Expressing hopelessness about the future
+ Extreme, prolonged sadness or distress
+ Expressing or showing feelings of isolation
+ Bragging about access to guns

**NOTE**

**This list is not a comprehensive list of warning signs nor does exhibiting one of these signs indicate imminent violence.**

According to the following article:

Flannery, D. J., Modzeleski, W. & Kretschmar, J. M. Violence and School Shootings. Curr Psychiatry Rep 15, 331 (2013). DOI: [10.1007/s11920-012-0331-6](https://doi.org/10.1007/s11920-012-0331-6)

>"To date, studies of school shootings have concluded that no
consistent and reliable profile of school shooters exist, and
most researchers and clinicians would agree that predicting
violent behavior is a slippery slope that will usually result in
more false positives than false negatives."

However, the article states thatprevious studies note some commonalites such as:

> "...most shooters were depressed, had experienced some significant
loss, felt persecuted or bullied by others, and had prior
difficulty coping or had previously tried suicide. Most of
the shooters did not, however, have a history of drug abuse
or violence or cruelty to animals, common psychiatric indicators of risk, nor did they report excessive exposure to
violence in the media (though many produced their own
violent themes in writings or drawings)."

When concerned about seeing troubling behaviors, tell a trusted adult or call 911, if there is an immediate threat.

</div>

Column {data-width=400}
-------------------------------------

### 

**Respond to Warning Signs**

Call 911 if you feel there is an immediate threat. 

Call [+1-844-5-SAYNOW](tel:18445729669) if you would to submit an anonymous safety concern.
```


```
Map {data-icon="fa-map"}
===================================== 

Column {data-width=1000}
------------------------------------- 
```   





## RA NOTES


Consult this document for a general overview:

+ case-study-structure-MO-notes

There are several datasets involved in this case study

+ Raw dataset (raw_data/K-12 SSDB (Public) - K-12 SSDB (Public) Linked.csv)
+ Geocoded dataset  (processed_data/shooting_data.csv)
+ Wrangled dataset (processed_data/shooting_data_wrangled)

This document uses the geocoded dataset to produce the wrangled dataset.

The wrangled dataset is then used to produce the dashboard in the other document.


The goecoding required to produce this case study took approximately 1.5-2 hours on a Macbook Air (2015). 



## RA Code

We will employ the following layout for the dashboard.

RMarkdown Dashboard Structure

+ Icon (48 x 48)
+ The Data
+ Column 1: Interactive Table
+ Column 2: Photo
+ US Statistics
+ Column 1 
+ Yearly Deaths
+ Yearly Cumulative Deaths
+ Deaths per Shooting
+ Column 2
+ Wounded
+ Deaths
+ Shooting Completed/Attempted Suicide
+ Median Shots Fired
+ Deaths, Shooter was Only Victim
+ Use of a Single Handgun
+ State Statistics
+ Sidebar
+ Column 1
+ Yearly Deaths
+ Yearly Cumulative Deaths
+ Deaths per Shooting
+ Map
+ Zoom (+)
+ Zoom (-)
+ Layer Controls
+ Provider Tiles
+ Circle Markers
+ Mini-map
+ About
+ Column 1
+ Disclaimer
+ How do I use this dashboard?
+ Does Open Case Studies have more resources I can access to learn about creating this dashboard?
+ Column 2: Photo
+ Tutorial
+ Step 1: Load the `flexdashboard` package
+ Step 2: Create and `RMD` document
+ Step 3: Create an appropriate `YAML`.
+ Step 4: Design the layout of the dashboard.
+ Step 5: Add content to the dashboard.
+ Hotline
+ Warning Signs
+ Response to Warning Signs
+ Source Code





# **Summary**
*** 

## Summary Plot

## Synopsis

# **Suggested Homework**
*** 

Create another dashboard with graphs and statistics featuring other elements within this dataset. For example, students may create graphs that explore what school events are reported to have more shootings.


# **Additional Information**
***

## Helpful Links

[RStudio](https://rstudio.com/products/rstudio/features/){target="_blank"}  
[Cheatsheet on RStuido IDE](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf){target="_blank"}  
[Other RStudio cheatsheets](https://rstudio.com/resources/cheatsheets/){target="_blank"}   
[Tidyverse](https://www.tidyverse.org/){target="_blank"}   

[Response bias](https://en.wikipedia.org/wiki/Response_bias)  
[Cross-Sectional data](https://en.wikipedia.org/wiki/Cross-sectional_data?oldformat=true)
[Population](https://en.wikipedia.org/wiki/Population?oldformat=true)
[Sample](https://en.wikipedia.org/wiki/Sampling_(statistics)?oldformat=true)
[Sampling methods](https://en.wikipedia.org/wiki/Sampling_(statistics)?oldformat=true){target="_blank"} 
[Inference](https://www.britannica.com/science/inference-statistics) 

[American Community Survey (ASC)](https://www.census.gov/programs-surveys/acs)  

See [here](https://en.wikipedia.org/wiki/American_Community_Survey) for more detailed information about the survey  
[Measure of America](https://www.ssrc.org/programs/view/moa/)   
[Social Science Research Council](https://www.ssrc.org/) 
   

[Piping in R](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html){target="_blank"}   
[Writing functions](https://r4ds.had.co.nz/functions.html)   
Also see [this case study](https://opencasestudies.github.io/ocs-bloomberg-vaping-case-study/){target="_blank"}  for more information on writing functions.   
[String manipulation cheatsheet](https://rstudio.com/resources/cheatsheets/){target="_blank"}  
[Table formats](https://en.wikipedia.org/wiki/Wide_and_narrow_data){target="_blank"}

[Regression](https://lindeloev.github.io/tests-as-linear/)    
[simple linear regression](https://en.wikipedia.org/wiki/Simple_linear_regression)   
[monotonic association](https://www.statisticshowto.com/monotonic-relationship/)   
[Kendall rank correlation coefficient](https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient?oldformat=true)   
[Null hypothesis](https://en.wikipedia.org/wiki/Null_hypothesis)   
[Alternative hypothesis](https://en.wikipedia.org/wiki/Alternative_hypothesis)   
[Probability](https://en.wikipedia.org/wiki/Probability)   
[one-sided and two-sided hypotheses](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)   
[Nonparametric](https://en.wikipedia.org/wiki/Nonparametric_statistics)     [Parametric](https://en.wikipedia.org/wiki/Parametric_statistics) 
[significance threshold](https://en.wikipedia.org/wiki/Statistical_significance)  
[Z score](https://en.wikipedia.org/wiki/Standard_score)   
[Z score table](https://socratic.org/questions/5986a3e1b72cff6fd48a5408)  
[Z score to p-value calculator](https://www.socscistatistics.com/pvalues/normaldistribution.aspx)   


[`ggplot2` package](http://ggplot2.tidyverse.org){target="_blank"}    
Please see [this case study](https://opencasestudies.github.io/ocs-bp-co2-emissions/)  for more details on using `ggplot2`    
[grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.html){target="_blank"}   
[`ggplot2` themes](https://ggplot2.tidyverse.org/reference/ggtheme.html){target="_blank"}   
[`directlabels` package methods](http://directlabels.r-forge.r-project.org/docs/index.html){target="_blank"}    
[Hmong people](https://en.wikipedia.org/wiki/Hmong_people)   
[Intersections](https://www.vox.com/the-highlight/2019/5/20/18542843/intersectionality-conservatism-law-race-gender-discrimination)   

[Motivating article for this case study about youth disconnection/opportunity youth](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6243446/)


To learn more about importing and wrangling PDFs using the `pdftools` package see this [case study](https://opencasestudies.github.io/ocs-bp-rural-and-urban-obesity/) and this [case study](https://opencasestudies.github.io/ocs-bp-rural-and-urban-obesity/). 

To learn more about what you can do with the `magick` package see this [vingette](https://cran.r-project.org/web/packages/magick/vignettes/intro.html).   

To learn more about the **Mann-Kendall trend test** see
[here](https://www.statisticshowto.com/mann-kendall-trend-test/) and [here](https://www.statisticshowto.com/wp-content/uploads/2016/08/Mann-Kendall-Analysis-1.pdf).  

To learn more about hypothesis testing, see this [case study](https://opencasestudies.github.io/ocs-bp-rural-and-urban-obesity/).    


<u>**Packages used in this case study:** </u>

Package   | Use in this case study                                                                      
---------- |-------------
[here](https://github.com/jennybc/here_here){target="_blank"}       | to easily load and save data  
[pdftools](https://readr.tidyverse.org/)      | to import PDF documents  
[magick](https://cran.r-project.org/web/packages/magick/vignettes/intro.html#Kernel_convolution)      | for importing images and extracting text from images   
[knitr](https://yihui.org/knitr/) |  for showing images in reports    
[dplyr](https://dplyr.tidyverse.org/){target="_blank"}      | to filter, subset, join, add rows to, and modify the data   
[stringr](https://stringr.tidyverse.org/){target="_blank"}      | to manipulate strings  
[magrittr](https://magrittr.tidyverse.org/){target="_blank"}      | to pipe sequential commands 
[tidyr](https://tidyr.tidyverse.org/){target="_blank"}      | to change the shape or format of tibbles to wide and long, to drop rows with `NA` values, to separate a column into additional columns, and to fill out values based on previous values   
[tibble](https://tibble.tidyverse.org/){target="_blank"}      | to create tibbles    
[ggplot2](https://ggplot2.tidyverse.org/){target="_blank"}      | to create plots  
[directlabels](http://directlabels.r-forge.r-project.org/docs/index.html){target="_blank"}      | to add labels directly to lines in plots  
[cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html){target="_blank"}      | to add images to plots 
[forcats](https://forcats.tidyverse.org/){target="_blank"}      | to reorder factor for plot
[kendall](https://cran.r-project.org/web/packages/Kendall/Kendall.pdf) | to implement the Mann-Kendall trend test in R   
[patchwork](https://github.com/thomasp85/patchwork) | to combine plots

#### {.emphasis_block}

**Warning Signs**

From [Sandy Hook Promise](https://www.sandyhookpromise.org/gun-violence/know-the-signs-of-gun-violence/)...

Here is a list of potential warning signs that can signal an individual may be in crisis and/or need help:

+ Suddenly withdrawing from people and activities
+ Consistent bullying or intimidating others, or being bullied by others
+ Extreme mood or personality changes
+ Victim of constant social rejection
+ Talking about plans or actively making plans to harm themselves or others
+ Bringing a weapon to school – or threatening or talking about doing so
+ Bragging about or warning others about an upcoming act of violence
+ Recruiting others to join in a planned act of violence
+ Warning students to stay away from school or events
+ Expressing fascination with guns and/or school shootings
+ Expressing hopelessness about the future
+ Extreme, prolonged sadness or distress
+ Expressing or showing feelings of isolation
+ Bragging about access to guns

**NOTE**

This list is not a comprehensive list of warning signs nor does exhibiting one of these signs indicate imminent violence.

When concerned about seeing troubling behaviors, tell a trusted adult or call 911, if there is an immediate threat.

**Respond to Warning Signs**

Call 911 if you feel there is an immediate threat. 

Call [+1-844-5-SAYNOW](tel:18445729669) if you would to submit an anonymous safety concern.


If you or your child or student experienced a shooting please see this [website](https://kidshealth.org/en/parents/ptsd.html) and this [website](https://www.verywellmind.com/shooting-ptsd-from-a-shooting-2797200) for guidance about dealing with the trauma.


####

## Session Info

```{r}
sessionInfo()
```


## Acknowledgements

We would like to acknowledge [Elizabeth Stuart](https://www.jhsph.edu/faculty/directory/profile/1792/elizabeth-a-stuart) for assisting in framing the major direction of the case study.

We would also like to acknowledge the [Bloomberg American Health Initiative](https://americanhealth.jhu.edu/) for funding this work. 

